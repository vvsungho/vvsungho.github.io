(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-0414f2d6"],{"1dde":function(t,s,n){var e=n("d039"),i=n("b622"),p=n("2d00"),a=i("species");t.exports=function(t){return p>=51||!e((function(){var s=[],n=s.constructor={};return n[a]=function(){return{foo:1}},1!==s[t](Boolean).foo}))}},2523:function(t,s,n){t.exports=n.p+"img/profile2.8b8bd88d.jpeg"},"3ca3":function(t,s,n){"use strict";var e=n("6547").charAt,i=n("69f3"),p=n("7dd0"),a="String Iterator",o=i.set,l=i.getterFor(a);p(String,"String",(function(t){o(this,{type:a,string:String(t),index:0})}),(function(){var t,s=l(this),n=s.string,i=s.index;return i>=n.length?{value:void 0,done:!0}:(t=e(n,i),s.index+=t.length,{value:t,done:!1})}))},"4de4":function(t,s,n){"use strict";var e=n("23e7"),i=n("b727").filter,p=n("1dde"),a=n("ae40"),o=p("filter"),l=a("filter");e({target:"Array",proto:!0,forced:!o||!l},{filter:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},"4df4":function(t,s,n){"use strict";var e=n("0366"),i=n("7b0b"),p=n("9bdd"),a=n("e95a"),o=n("50c4"),l=n("8418"),r=n("35a1");t.exports=function(t){var s,n,f,y,b,g,m=i(t),c="function"==typeof this?this:Array,d=arguments.length,u=d>1?arguments[1]:void 0,h=void 0!==u,v=r(m),z=0;if(h&&(u=e(u,d>2?arguments[2]:void 0,2)),void 0==v||c==Array&&a(v))for(s=o(m.length),n=new c(s);s>z;z++)g=h?u(m[z],z):m[z],l(n,z,g);else for(y=v.call(m),b=y.next,n=new c;!(f=b.call(y)).done;z++)g=h?p(y,u,[f.value,z],!0):f.value,l(n,z,g);return n.length=z,n}},6062:function(t,s,n){"use strict";var e=n("6d61"),i=n("6566");t.exports=e("Set",(function(t){return function(){return t(this,arguments.length?arguments[0]:void 0)}}),i)},6547:function(t,s,n){var e=n("a691"),i=n("1d80"),p=function(t){return function(s,n){var p,a,o=String(i(s)),l=e(n),r=o.length;return l<0||l>=r?t?"":void 0:(p=o.charCodeAt(l),p<55296||p>56319||l+1===r||(a=o.charCodeAt(l+1))<56320||a>57343?t?o.charAt(l):p:t?o.slice(l,l+2):a-56320+(p-55296<<10)+65536)}};t.exports={codeAt:p(!1),charAt:p(!0)}},6566:function(t,s,n){"use strict";var e=n("9bf2").f,i=n("7c73"),p=n("e2cc"),a=n("0366"),o=n("19aa"),l=n("2266"),r=n("7dd0"),f=n("2626"),y=n("83ab"),b=n("f183").fastKey,g=n("69f3"),m=g.set,c=g.getterFor;t.exports={getConstructor:function(t,s,n,r){var f=t((function(t,e){o(t,f,s),m(t,{type:s,index:i(null),first:void 0,last:void 0,size:0}),y||(t.size=0),void 0!=e&&l(e,t[r],{that:t,AS_ENTRIES:n})})),g=c(s),d=function(t,s,n){var e,i,p=g(t),a=u(t,s);return a?a.value=n:(p.last=a={index:i=b(s,!0),key:s,value:n,previous:e=p.last,next:void 0,removed:!1},p.first||(p.first=a),e&&(e.next=a),y?p.size++:t.size++,"F"!==i&&(p.index[i]=a)),t},u=function(t,s){var n,e=g(t),i=b(s);if("F"!==i)return e.index[i];for(n=e.first;n;n=n.next)if(n.key==s)return n};return p(f.prototype,{clear:function(){var t=this,s=g(t),n=s.index,e=s.first;while(e)e.removed=!0,e.previous&&(e.previous=e.previous.next=void 0),delete n[e.index],e=e.next;s.first=s.last=void 0,y?s.size=0:t.size=0},delete:function(t){var s=this,n=g(s),e=u(s,t);if(e){var i=e.next,p=e.previous;delete n.index[e.index],e.removed=!0,p&&(p.next=i),i&&(i.previous=p),n.first==e&&(n.first=i),n.last==e&&(n.last=p),y?n.size--:s.size--}return!!e},forEach:function(t){var s,n=g(this),e=a(t,arguments.length>1?arguments[1]:void 0,3);while(s=s?s.next:n.first){e(s.value,s.key,this);while(s&&s.removed)s=s.previous}},has:function(t){return!!u(this,t)}}),p(f.prototype,n?{get:function(t){var s=u(this,t);return s&&s.value},set:function(t,s){return d(this,0===t?0:t,s)}}:{add:function(t){return d(this,t=0===t?0:t,t)}}),y&&e(f.prototype,"size",{get:function(){return g(this).size}}),f},setStrong:function(t,s,n){var e=s+" Iterator",i=c(s),p=c(e);r(t,s,(function(t,s){m(this,{type:e,target:t,state:i(t),kind:s,last:void 0})}),(function(){var t=p(this),s=t.kind,n=t.last;while(n&&n.removed)n=n.previous;return t.target&&(t.last=n=n?n.next:t.state.first)?"keys"==s?{value:n.key,done:!1}:"values"==s?{value:n.value,done:!1}:{value:[n.key,n.value],done:!1}:(t.target=void 0,{value:void 0,done:!0})}),n?"entries":"values",!n,!0),f(s)}}},"65f0":function(t,s,n){var e=n("861d"),i=n("e8b5"),p=n("b622"),a=p("species");t.exports=function(t,s){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)?e(n)&&(n=n[a],null===n&&(n=void 0)):n=void 0),new(void 0===n?Array:n)(0===s?0:s)}},"6d61":function(t,s,n){"use strict";var e=n("23e7"),i=n("da84"),p=n("94ca"),a=n("6eeb"),o=n("f183"),l=n("2266"),r=n("19aa"),f=n("861d"),y=n("d039"),b=n("1c7e"),g=n("d44e"),m=n("7156");t.exports=function(t,s,n){var c=-1!==t.indexOf("Map"),d=-1!==t.indexOf("Weak"),u=c?"set":"add",h=i[t],v=h&&h.prototype,z=h,x={},q=function(t){var s=v[t];a(v,t,"add"==t?function(t){return s.call(this,0===t?0:t),this}:"delete"==t?function(t){return!(d&&!f(t))&&s.call(this,0===t?0:t)}:"get"==t?function(t){return d&&!f(t)?void 0:s.call(this,0===t?0:t)}:"has"==t?function(t){return!(d&&!f(t))&&s.call(this,0===t?0:t)}:function(t,n){return s.call(this,0===t?0:t,n),this})};if(p(t,"function"!=typeof h||!(d||v.forEach&&!y((function(){(new h).entries().next()})))))z=n.getConstructor(s,t,c,u),o.REQUIRED=!0;else if(p(t,!0)){var w=new z,C=w[u](d?{}:-0,1)!=w,A=y((function(){w.has(1)})),S=b((function(t){new h(t)})),F=!d&&y((function(){var t=new h,s=5;while(s--)t[u](s,s);return!t.has(-0)}));S||(z=s((function(s,n){r(s,z,t);var e=m(new h,s,z);return void 0!=n&&l(n,e[u],{that:e,AS_ENTRIES:c}),e})),z.prototype=v,v.constructor=z),(A||F)&&(q("delete"),q("has"),c&&q("get")),(F||C)&&q(u),d&&v.clear&&delete v.clear}return x[t]=z,e({global:!0,forced:z!=h},x),g(z,t),d||n.setStrong(z,t,c),z}},7156:function(t,s,n){var e=n("861d"),i=n("d2bb");t.exports=function(t,s,n){var p,a;return i&&"function"==typeof(p=s.constructor)&&p!==n&&e(a=p.prototype)&&a!==n.prototype&&i(t,a),t}},8418:function(t,s,n){"use strict";var e=n("c04e"),i=n("9bf2"),p=n("5c6c");t.exports=function(t,s,n){var a=e(s);a in t?i.f(t,a,p(0,n)):t[a]=n}},"99af":function(t,s,n){"use strict";var e=n("23e7"),i=n("d039"),p=n("e8b5"),a=n("861d"),o=n("7b0b"),l=n("50c4"),r=n("8418"),f=n("65f0"),y=n("1dde"),b=n("b622"),g=n("2d00"),m=b("isConcatSpreadable"),c=9007199254740991,d="Maximum allowed index exceeded",u=g>=51||!i((function(){var t=[];return t[m]=!1,t.concat()[0]!==t})),h=y("concat"),v=function(t){if(!a(t))return!1;var s=t[m];return void 0!==s?!!s:p(t)},z=!u||!h;e({target:"Array",proto:!0,forced:z},{concat:function(t){var s,n,e,i,p,a=o(this),y=f(a,0),b=0;for(s=-1,e=arguments.length;s<e;s++)if(p=-1===s?a:arguments[s],v(p)){if(i=l(p.length),b+i>c)throw TypeError(d);for(n=0;n<i;n++,b++)n in p&&r(y,b,p[n])}else{if(b>=c)throw TypeError(d);r(y,b++,p)}return y.length=b,y}})},"9bdd":function(t,s,n){var e=n("825a"),i=n("2a62");t.exports=function(t,s,n,p){try{return p?s(e(n)[0],n[1]):s(n)}catch(a){throw i(t),a}}},a630:function(t,s,n){var e=n("23e7"),i=n("4df4"),p=n("1c7e"),a=!p((function(t){Array.from(t)}));e({target:"Array",stat:!0,forced:a},{from:i})},a640:function(t,s,n){"use strict";var e=n("d039");t.exports=function(t,s){var n=[][t];return!!n&&e((function(){n.call(null,s||function(){throw 1},1)}))}},abef:function(t,s,n){"use strict";var e=function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",[e("b-navbar",{staticClass:"fixed-header",attrs:{type:"dark",variant:"dark"}},[e("b-navbar-nav",[e("b-nav-item",[e("img",{staticStyle:{width:"30px","border-radius":"50%"},attrs:{src:n("2523"),alt:""},on:{click:function(s){return t.movePage("about")}}})]),e("b-nav-item",{class:"home"===t.checkActiveMenu?"font-weight-bold":"",on:{click:function(s){return t.movePage("home")}}},[t._v("Home")]),e("b-nav-item",{class:"about"===t.checkActiveMenu?"font-weight-bold":"",on:{click:function(s){return t.movePage("about")}}},[t._v("About")]),e("b-nav-item",{class:"posts"===t.checkActiveMenu||"postDetail"===t.checkActiveMenu?"font-weight-bold":"",on:{click:function(s){return t.movePage("posts")}}},[t._v("Posts")])],1)],1)],1)},i=[],p=(n("b0c0"),{name:"sidebafont-awesome-icon",data:function(){return{}},computed:{checkActiveMenu:function(){return this.$route.name}},methods:{movePage:function(t){if(this.$route.name===t)return!1;this.$router.push({name:t})}}}),a=p,o=(n("e20f"),n("2877")),l=Object(o["a"])(a,e,i,!1,null,"6767d9c0",null);s["a"]=l.exports},ae40:function(t,s,n){var e=n("83ab"),i=n("d039"),p=n("5135"),a=Object.defineProperty,o={},l=function(t){throw t};t.exports=function(t,s){if(p(o,t))return o[t];s||(s={});var n=[][t],r=!!p(s,"ACCESSORS")&&s.ACCESSORS,f=p(s,0)?s[0]:l,y=p(s,1)?s[1]:void 0;return o[t]=!!n&&!i((function(){if(r&&!e)return!0;var t={length:-1};r?a(t,1,{enumerable:!0,get:l}):t[1]=1,n.call(t,f,y)}))}},b0c0:function(t,s,n){var e=n("83ab"),i=n("9bf2").f,p=Function.prototype,a=p.toString,o=/^\s*function ([^ (]*)/,l="name";e&&!(l in p)&&i(p,l,{configurable:!0,get:function(){try{return a.call(this).match(o)[1]}catch(t){return""}}})},b727:function(t,s,n){var e=n("0366"),i=n("44ad"),p=n("7b0b"),a=n("50c4"),o=n("65f0"),l=[].push,r=function(t){var s=1==t,n=2==t,r=3==t,f=4==t,y=6==t,b=7==t,g=5==t||y;return function(m,c,d,u){for(var h,v,z=p(m),x=i(z),q=e(c,d,3),w=a(x.length),C=0,A=u||o,S=s?A(m,w):n||b?A(m,0):void 0;w>C;C++)if((g||C in x)&&(h=x[C],v=q(h,C,z),t))if(s)S[C]=v;else if(v)switch(t){case 3:return!0;case 5:return h;case 6:return C;case 2:l.call(S,h)}else switch(t){case 4:return!1;case 7:l.call(S,h)}return y?-1:r||f?f:S}};t.exports={forEach:r(0),map:r(1),filter:r(2),some:r(3),every:r(4),find:r(5),findIndex:r(6),filterOut:r(7)}},b7cb:function(t,s,n){},bb2f:function(t,s,n){var e=n("d039");t.exports=!e((function(){return Object.isExtensible(Object.preventExtensions({}))}))},c975:function(t,s,n){"use strict";var e=n("23e7"),i=n("4d64").indexOf,p=n("a640"),a=n("ae40"),o=[].indexOf,l=!!o&&1/[1].indexOf(1,-0)<0,r=p("indexOf"),f=a("indexOf",{ACCESSORS:!0,1:0});e({target:"Array",proto:!0,forced:l||!r||!f},{indexOf:function(t){return l?o.apply(this,arguments)||0:i(this,t,arguments.length>1?arguments[1]:void 0)}})},d81d:function(t,s,n){"use strict";var e=n("23e7"),i=n("b727").map,p=n("1dde"),a=n("ae40"),o=p("map"),l=a("map");e({target:"Array",proto:!0,forced:!o||!l},{map:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},ddb0:function(t,s,n){var e=n("da84"),i=n("fdbc"),p=n("e260"),a=n("9112"),o=n("b622"),l=o("iterator"),r=o("toStringTag"),f=p.values;for(var y in i){var b=e[y],g=b&&b.prototype;if(g){if(g[l]!==f)try{a(g,l,f)}catch(c){g[l]=f}if(g[r]||a(g,r,y),i[y])for(var m in p)if(g[m]!==p[m])try{a(g,m,p[m])}catch(c){g[m]=p[m]}}}},e20f:function(t,s,n){"use strict";n("b7cb")},e8b5:function(t,s,n){var e=n("c6b6");t.exports=Array.isArray||function(t){return"Array"==e(t)}},ebeb:function(t,s,n){"use strict";n("99af"),n("4de4"),n("a630"),n("c975"),n("d81d"),n("d3b7"),n("6062"),n("3ca3"),n("ddb0");var e={data:function(){return{items:[{key:"1",sort:1,tags:["알고리즘","백준","자바"],title:"백준 알고리즘 1966번",content:"백준 알고리즘 1966번"},{key:"2",sort:2,tags:["알고리즘","자바"],title:"Java DFS(Depth First Search) 구현하기",content:'<h3><strong>1. 그래프의 탐색</strong></h3>\n<ul>\n  <li>그래프의 탐색은 하나의 정점으로 부터 시작하여 모든 정점을 차례대로 한 번씩 방문하는 것을 의미한다. 예를 들어 특정 도시에서 다른 도시로의 이동 여부 판별이나 회로에서 단자와 단자의 연결 여부 확인 등에\n    사용된다.\n  </li>\n  <li>그래프 탐색에서 대중적으로 많이 알려진 알고리즘이 DFS와 BFS이다.</li>\n</ul><h4><br></h4><h3><strong>2. 깊이 우선 탐색 (DFS, Depth First Search)</strong></h3>\n<ul>\n  <li>DFS는 루트 노드와 임의 노드에서 시작하여 최대한 깊숙히 들어가서 탐색한 후 다시 원점으로 돌아가 다른 루트로 탐색하는 방식이다.</li>\n  <li>일반적으로 재귀호출을 사용하여 구현하며, 단순한 스택이나 인접 행렬, 인접 리스트를 이용하여 구현하기도 한다. 스택을 사용할 경우는 오버플로우를 유의해야 한다.</li>\n  <li>DFS는 자동 미로 생성 또는 미로 탐색에 사용되는데 다음과 같은 특징이 있다.</li>\n  <li class="ql-indent-1">미로 탐색시 한 방향으로 갈 수 있을 때 까지 계속 탐색.</li>\n  <li class="ql-indent-1">막다른 곳에 도달하면 막다른 길에 대한 표식을 남기고 가장 가까운 갈림길로 돌아와 다시 탐색을 진행. 이러한 방법으로 갈림길을 순차적으로 탐색하여 목적지까지의 경로를\n    구함.\n  </li>\n  <li class="ql-indent-1">넓게(BreadTh) 탐색하기 전에 깊게(Depth) 탐색함.</li>\n  <li class="ql-indent-1">모든 노드를 방문하고자 하는 경우에 사용.</li>\n  <li class="ql-indent-1">자기 자신을 호출하는 순환 알고리즘의 형태(재귀호출)</li>\n  <li class="ql-indent-1">노드 방문 여부를 반드시 검사해야함. 그렇지 않으면 무한 루프에 빠질 위험이 있음.</li>\n  <li>DFS 장점</li>\n  <li class="ql-indent-1">구현이 BFS보다 간단하다.</li>\n  <li class="ql-indent-1">현재 경로상의 노드들만 기억하면 되므로, 저장공간의 수요가 비교적 작음.</li>\n  <li class="ql-indent-1">목표 노드가 깊은 단계에 있는 경우 해를 빨리 구할 수 있음.</li>\n  <li>DFS 단점</li>\n  <li class="ql-indent-1">단순 검색 속도는 BFS보다 느림.</li>\n  <li class="ql-indent-1">해가 없는 경우에 빠질 가능성이 있음. 이러한 경우 사전에 임의의 깊이를 지정한 후 탐색하도록 하고, 목표 노드를 발견하지 못할 경우 다음 경로를 탐색하도록 함.\n  </li>\n  <li class="ql-indent-1">DFS는 해를 구하면 탐색이 종료되므로, 구한 해가 최단경로가 된다는 보장이 없음.</li>\n  <li class="ql-indent-1">목표에 이르는 경로가 다수인 경우 구한 해가 최적이 아닐 수 있음.</li>\n</ul><p><br></p><p><br></p><p><br></p><template>\n  <div style="padding: 2rem">\n    <b-card-title class="text-left">Editor</b-card-title>\n    <editor\n        :initialValue="editorText"\n        :options="editorOptions"\n        height="auto"\n        initialEditType="wysiwyg"\n        previewStyle="vertical"\n        ref="toastuiEditor"\n    />\n    \x3c!--    @change="getHtml"--\x3e\n\n    <div style="margin-top: 1rem" class="text-right">\n      <b-button variant="primary" size="sm" @click="getHtml">HTML TO TEXT</b-button>\n    </div>\n\n    <div>\n      <b-card-title class="text-left" style="margin-top: 1rem">Text</b-card-title>\n      <b-card style="margin-top: 1rem">\n        <div class="text-left" v-html="htmlText" style="height: 300px">\n\n        </div>\n      </b-card>\n    </div>\n  </div>\n</template>\n<script>\nimport \'codemirror/lib/codemirror.css\';\nimport \'@toast-ui/editor/dist/toastui-editor.css\';\n\nimport { Editor } from \'@toast-ui/vue-editor\';\n\nexport default {\n  components: {\n    editor: Editor\n  },\n  data() {\n    return {\n      editorText: \'텍스트를 입력하세요.\',\n      editorOptions: {\n        hideModeSwitch: true\n      },\n      htmlText: \'텍스트를 입력하세요.\'\n    };\n  },\n  methods: {\n    getHtml() {\n      this.htmlText = this.$refs.toastuiEditor.invoke(\'getHtml\');\n    }\n  }\n};\n<\/script>\n\n<style>\n  .tui-editor-defaultUI {\n    text-align: left !important;\n  }\n</style>'},{key:"3",sort:3,tags:["자바","스프링"],title:"Java, Spring Framework 주요 개념 요약",content:'<div class="tt_article_useless_p_margin"><p><b><span style="font-size: 18pt;">OOP란?</span></b><b><span style="font-size: 12pt;"></span></b></p>\n<p><span style="font-size: 12pt;">&nbsp;데이터를 객체로 취급하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동장하는 기존의 것들과 다르게 객체의 상호작용을 통해 프로그램이 동작하는 것을 말한다. 캡슐화, 다형성, 상속을 이용하여 코드 재사용성을 증가시키고, 유지보수를 손쉽게 하는&nbsp;장점을 얻기 위해서 객체들을 연결 시켜 프로그래밍 하는 것이다.&nbsp;</span></p>\n<p>&nbsp;</p>\n<p><b><span style="font-size: 18pt;">자바의 메모리 영역</span></b><b><span style="font-size: 14pt;"></span></b></p>\n<p><span style="font-size: 12pt;">1. 메서드(Method) 영역 ; static변수, 인스턴스 변수를 가리키는 전역변수와&nbsp;코드에서 사용되는 Class 정보등이 올라간다. 코드에서 사용되는 class를 로더로 읽어 클래스별로 필드에티ㅓ, 메서드 데이터 등을 분류해 저장한다.</span></p>\n<p><span style="font-size: 12pt;">2. 스택(Stack) : 지역변수, 함수(메서드) 등이 할당되는 LIFO 방식의 메모리.</span></p>\n<p><span style="font-size: 12pt;">3. 힙(Heap) : new 연산자를 통한 동적할당된 객체들이 저장되며, 가비지 컬렉션에 의해 메모리가 관리된다.</span></p>\n<p>&nbsp;</p>\n<p><b><span style="font-size: 18pt;">자바의 클래스 멤버 변수 초기화 순서</span></b><span style="font-size: 12pt;"></span></p>\n<p><span style="font-size: 12pt;">1. static 변수 선언부 : 클래스가 로드 될 때 변수가 제일 먼저 초기화 된다. 메모리 모델 상 Method area에 올라간다.</span></p>\n<p><span style="font-size: 12pt;">2. 필드 변수 선언부 : 객체생성 될 때 생성자 block 보다 앞서 초기화 된다.</span></p>\n<p><span style="font-size: 12pt;">3. 생성자 block : 객체생성 될 때 JVM이 내부적으로 locking 한다. 필드 변수 중 final 변수의 가시화(다른 스레드에 공개하는 시점)는 생성자 block이 끝난 다음이다.&nbsp;필드 변수 선언부에서 이미 초기화 되었다면 필드 변수 선언부에서 이미 초괴화 되었다면 그 값들은 덮어쓴다.&nbsp;&nbsp;</span></p>\n<p><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">&nbsp;</span><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">ㆍ초기화시점&nbsp;</span></p>\n<p><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">&nbsp;1) 클래스변수의 초기화 순서 : 기본값 -&gt; 명시적초기화 -&gt; 클래스초기화블럭</span></p>\n<p><span style="font-size: 12pt;">&nbsp;2) 인스턴스변수의 초기화 순서: 기본값 -&gt; 명시적초기화 -&gt; 인스턴스 초기화블럭 -&gt; 생성자</span></p>\n<p>&nbsp;</p>\n<p><b><span style="font-size: 18pt;">메모리 상수풀 영역이란?</span></b></p>\n<p><span style="font-size: 12pt;">&nbsp;힙역역에 생성되어 자바프로세스 종료까지 계속 유지되는 메모리 영역이다. 기본적으로 JVM이 관리하며 프로그래머가 작성한 상수에 대해 최우선적으로 찾아보고 없으면 상수풀에 추가한 이후 그 주소값을 리턴한다. 그로인해 메모리 절약 효과가 있다.&nbsp;</span></p>\n<p>&nbsp;</p>\n<p><b><span style="font-size: 18pt;">인터페이스란?</span></b></p>\n<p><span style="font-size: 12pt;">&nbsp;인터페이스는 모든 메서드가 구현부가 없는 추상메서드로 이루어진 클래스로, abstract 키워드를 붙이지 않아도 자동으로 모든 메서드는 추상메서드로 정의된다. 또한 변수도 자동으로&nbsp; final static키워드가 붙게 된다.</span></p>\n<p>&nbsp;</p>\n<p><span style="font-size: 14pt;"><b><span style="font-size: 18pt;">왜 인터페이스를 사용하는가?</span></b></span></p>\n<p><span style="font-size: 12pt;">&nbsp;팀 작업시 개발 코드 부분과 객체가 서로 통신하는 점점 역할을 지원하게 되는데, 이는 개발코드에선 객체의 내부구조를 모르더라도 인터페이스의 메서드 명만 알고 있으면 되기 때문이다. 이를 통해 얻을 수 있는 장점은 해당 메서드를 통해 나오는 결과물을 알고 있기 때문에 다른 팀의 작업을 기다리고 있지 않아도 되며, 또한 해당 객체가 수정될 경우 개발 코드 부분은 수정을 하지 않아도 된다. 또한, 부가적으로 객체를 파일에 쓰기 위해 Serializable 인터페이스를 구현하거나, Collection.sort()를 하기위해서 Comparable 인터페이스를 상속하는것, Cloneable을 구현하는 것처럼 특정 작업을 하겠다라는 \'Mark 역할을 해주기도 한다.</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><b><span style="font-size: 18pt;">JDBC란 무엇인가?</span></b></p>\n<p><span style="font-size: 12pt;">자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다. JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법을 제공한다.&nbsp;</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style="font-size: 18pt;"><b>직렬화란 무엇인가?</b></span></p>\n<p><span style="font-size: 12pt;">&nbsp;자바에서 입출력에 사용되는 것은 스트림을 이용하고 데이터 통로를 통해 이동한다. 하지만 객체는 바이트형이 아니기 때문에 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없다. 따라서 객체를 스트림을 통해 입출력 하려면 바이트 배열로 변환하는 것이 필요한데, 이를 직렬화라고 한다.반대로 스트림을 통해 받은 직력화 된 객체를 원래모양으로 만드는 과정을 역직렬화라고 한다.&nbsp;</span></p>\n<p>&nbsp;</p>\n<p><span style="font-size: 18pt;"><b>serialVersionUID를 선언해야 하는 이유</b></span></p>\n<p><span style="font-size: 12pt;">&nbsp;자바가상기계 (JVM)은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여한다. 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당한다. 그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수 도 있다. 이런 문제를 해결하기 위해 serialVesionUID를 사용한다. 즉, seralVesionUID값을 저장할 때 클래스 버전이 맞는지 확인하기 위한 용도이다. 만약 직렬화 할 때 사용한 serialVersionUID의 값과 역직렬화 하기 위해 사용했던 seralVesionUID값이 다르다면 InvalidClassException이 발생할 수 있다.</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><span style="font-size: 18pt;"><b>리플렉션이란 무엇인가?</b></span></p>\n<p><span style="font-size: 12pt;">&nbsp;리플렉션은 컴파일러를 무시하고 런타임 상황에서 메모리에 올라간 클래스나 메서드 등의 정의를 동적으로 찾아서 조작할 수 있는 일련의 행위를 말한다. 즉 동적인 언어ㅢ 특징이라 말 할 수 있다. 프레임워크에서 유연성이 있는 동작을 위해 자주 사용한다.&nbsp;</span></p>\n<p><span style="font-size: 12pt;">&nbsp;</span></p>\n<p><span style="font-size: 12pt;">&nbsp;</span></p>\n<p><span style="font-size: 16px;"><b><span style="font-size: 18pt;">제너릭</span></b></span></p>\n<p><span style="font-size: 12pt;">&nbsp;클래스를 선언할 때 타입을 결정하지 않고 객체를 생성할 때 유동적인 타입으로 재사용하기 위한 것이다. 형변환을 할 필요 없고, 타입 에러가 발생할 확률이 없어진다. 타입추론은 메서드를 호출하는 코드에서 타입인자가 정의한대로 제대로 쓰였는지 살펴보는 컴파일러의 능력이다.&nbsp;</span></p>\n<p>&nbsp;</p>\n<p><span style="font-size: 12pt;"><b><span style="font-size: 18pt;">컬렉션(collection) 클래스에서 제너릭을 사용하는 이유를 설명하시오.</span></b></span><span style="font-size: 12pt;"></span></p>\n<p><span style="font-size: 12pt;">&nbsp;<span style="font-size: 12pt;">컬렉션 클래스에서 제네릭을 사용하면 컴파일러는 특정타입만 포함될 수 있도록 컬렉션을 제한한다. 컬렉션 클래스에 저장하는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파일타임에 잡아낼 수 있도록 도와준다.&nbsp;</span></span></p>\n<p><span style="font-size: 12pt;">&nbsp;</span></p>\n<p><span style="font-size: 12pt;">&nbsp;</span></p>\n<p><span style="font-size: 16px;"><b><span style="font-size: 18pt;">박싱과 언박싱은 무엇인가?</span></b></span><span style="font-size: 16px;"></span></p>\n<p><span style="font-size: 12pt;">ㆍprimitive type : int, double과 같은 </span><span style="font-size: 12pt;">기본자료형</span></p>\n<p><span style="font-size: 12pt;">ㆍwrapper class : 객체 자료형. 참조 자료형.</span></p>\n<p><span style="font-size: 12pt;">&nbsp;wrapper class</span><span style="font-size: 12pt;">명은 int, char형을 제외하고 </span><span style="font-size: 12pt;">기본자료형의 첫 문자를 대문자로 바꾸면 된다.&nbsp;</span><span style="font-size: 12pt;"></span></p>\n<p></p><figure class="imageblock alignCenter" width="591" height="459" data-origin-width="591" data-origin-height="459" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/9917744A5C96220925" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/9917744A5C96220925" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9917744A5C96220925" width="591" height="459" data-origin-width="591" data-origin-height="459" data-ke-mobilestyle="widthContent"></span></figure><p></p>\n<p style="text-align: center;"><span style="font-size: 8pt;">[표1] </span><span style="font-size: 8pt;">출처:&nbsp;</span><span style="font-size: 16px;"><a class="tx-link" href="https://studymake.tistory.com/420" target="_blank" rel="noopener"><span style="font-size: 8pt;">https://studymake.tistory.com/420</span></a></span></p>\n<p>&nbsp;</p>\n<p><span style="font-size: 12pt;">1. 박싱 : 상자를 꾸리다. 기본형을 참조형으로 변환하는 것.</span></p>\n<p><span style="font-size: 12pt;">2. 언박싱 : 상자에서 꺼내다. 참조형을 기본형으로 변환하는</span><span style="font-size: 12pt;">&nbsp;것.</span></p>\n<p><span style="font-size: 12pt;">&nbsp;</span></p>\n<p></p><figure class="imageblock alignCenter" width="573" height="259" data-origin-width="573" data-origin-height="259" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/996574475C96252838" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/996574475C96252838" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F996574475C96252838" width="573" height="259" data-origin-width="573" data-origin-height="259" data-ke-mobilestyle="widthContent"></span></figure><p></p>\n<p><span style="font-size: 12pt;">&nbsp;</span></p>\n<p style="margin-left: 2em;"><span style="font-size: 16px;">ㆍ묵시적박싱 = 오토박싱</span></p>\n<p style="margin-left: 2em;"><span style="font-size: 16px;">ㆍ명시적 = 직접 명시하여 박싱 or 언방</span></p>\n<p style="margin-left: 2em;">&nbsp;</p>\n<p style="margin-left: 2em;"><b><span style="font-size: 18pt;">데드락이란?</span></b></p>\n<p style="margin-left: 2em;">&nbsp;<span style="font-size: 12pt;">데드락이란, 둘 이상의 쓰레드가 lock을 획득하기 위해 기다리는데, 이 lock을 잡고 있는 쓰레드도 똑같이 다른 lock을 기다리며 서로 블록상태에 놓이는 것을 말한다. 데드락은 다수의 쓰레드가 같은 lock을, 동시에 다른 명령에 의해 획득하려 할 때 발생할 수 있다.&nbsp;</span></p>\n<p style="margin-left: 2em;"><span style="font-size: 12pt;">- 해결방안</span></p>\n<ul style="list-style-type: disc;">\n<ul style="list-style-type: disc;">\n<ul style="list-style-type: disc;">\n<li><span style="font-size: 12pt;">자원 유형에 따라 우선 순위를 선정하여 자원을 선점하게 한다.</span></li>\n<li><span style="font-size: 12pt;">공유 불가능한</span><span style="font-size: 12pt;">&nbsp;상호배제 조건을 제거한다.&nbsp;</span></li>\n</ul>\n</ul>\n</ul>\n<div>\n<p style="margin-left: 2em;"><span style="font-size: 24px;"><b>Spring에서 AOP란?</b></span></p>\n<p style="margin-left: 2em;">&nbsp;&nbsp;<span style="font-size: 16px;">AOP는 Aspect Orientd Programming, 관점 지향 프로그래밍의 약자로, 중복코드가 발생하는 해결하고자 나온 방식이다. 횡단 코드를 횡단관심사라고 표현하여 개발코드에서는 비지니스 로직에 집중하고 실행 시에 비지니스 로직 앞, 뒤 등 원하는 위치에 해당 공통 관심사를 수행할 수 있게 함으로써 중복 코드를 줄이는 방법이다.&nbsp;</span></p>\n<p style="margin-left: 2em;">&nbsp;</p>\n<p style="margin-left: 2em;"><span style="font-size: 16px;"><b><span style="font-size: 18pt;">의존성이란?&nbsp;</span></b></span></p>\n<p style="margin-left: 2em;">&nbsp; <span style="font-size: 16px;">사용할 작업 클래스에 의존하는 성격을 말합니다. 즉, 클래스에서 변경이 일어 났을 때 다른 클래스가 영향을 많이 받을 때, 의존성이 높다고 한다. 의존성을 낮추기 위해 interface를 사용한다.&nbsp;</span></p>\n<figure class="imageblock alignCenter" width="349" height="495" data-origin-width="349" data-origin-height="495" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/99A79B4B5C98A86837" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/99A79B4B5C98A86837" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99A79B4B5C98A86837" width="349" height="495" data-origin-width="349" data-origin-height="495" data-ke-mobilestyle="widthContent"></span></figure>\n<p style="margin-left: 2em;"><span style="font-size: 16px;">&nbsp;위의 WorkClass는 ClassA에 매우 의존적이다. WorkClass는 ClassA 작업밖에 하지 못한다. 다른 작업을 원한다면 ClassA의 내용을 바꾸거나, 다른클래스를 생성해서 작업해야 한다. interface를 만들면 의존성을 보다 낮출 수 있다.&nbsp;</span><span style="font-size: 16px;"></span></p>\n<figure class="imageblock alignCenter" width="860" height="654" data-origin-width="860" data-origin-height="654" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/99765E445C98AA3537" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/99765E445C98AA3537" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99765E445C98AA3537" width="860" height="654" data-origin-width="860" data-origin-height="654" data-ke-mobilestyle="widthContent"></span></figure>\n<p style="margin-left: 2em;"><span style="font-size: 16px;">&nbsp;메인클래스의 ClassInter inter 객체가 다른 작업을 하고 싶다면 new ClassA() 대신 ClassB()로&nbsp;바꾸면 된다. 객체를 사용하는 객체명을 하나하나&nbsp;바꿀 필요가 없다. 그러나 여전히 내부에서 선언한 내용을 수정해야하는 단점이 있다. (ClassA를 ClassB로)</span></p>\n<p style="margin-left: 2em;">&nbsp;</p>\n<p style="margin-left: 2em;"><b>Spring에서 IOC란?</b></p>\n<p style="margin-left: 2em;"><b>&nbsp;</b>&nbsp;<span style="font-size: 16px;">Inversion Of Control은 제어의 역전이라 한다. 스프링을 쓰기 전에는 개발자가 프로그램의 흐름을 제어하는 주체였다. 스프링에서는 프로그램의 흐름을 프레임워크가 주도하게 된다. \'@Autowired\' 등으로 Bean을 자동주입하고 객체의 생성의 생명주기 관리를 컨테이너가 도맡아한다. 즉 제어권이 컨테이너로 넘어가는 것을 말한다. 제어권이 컨테이너로 넘어옴으로써 DI, AOP등이 가능하게 된다.&nbsp;</span></p>\n<p style="margin-left: 2em;"><span style="font-size: 16px;">&nbsp;</span></p>\n<p style="margin-left: 2em;"><span style="font-size: 16px;">&nbsp;</span></p>\n<p style="margin-left: 2em;"><span style="font-size: 24px;"><b>Spring에서 DI란?</b></span></p>\n<ul style="list-style-type: disc;">\n<li><span style="font-size: 12pt;">각 클래스 간의 의존관계를 빈설정(xml 이나 annotation) 정보를 바탕으로 컨테이너가 자동으로 연결해주는 것을 말한다. 즉 클래스 간의 의존관계를 컨테이너가 주입한다.&nbsp;</span></li>\n<li><span style="font-size: 12pt;">DI는 Dependency Injection의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 방식으로, 객체간의 의존성을 자신이 아닌 외부에서 주입하는 개념이다.&nbsp;</span></li>\n<li><span style="font-size: 12pt;">스프링은 다른 객체들이 사용하고, 다른 서비스를 위해 사용할 수 있는 클래스를 컨테이너 형태로 이 기능을 제공한다. A라는 객체에서 B, C객체를 사용(의존)할 때 A객체에서 직접 생성을 하는 것이 아닌 외부(IOC컨테이너)에서 생성된 B, C객체를 주입 시켜 setter 혹은 생성자를 통해 사용할 수 있다.</span></li>\n</ul>\n<ul style="list-style-type: disc;">\n<li><span style="font-size: 12pt;"><b>DI유형</b></span></li>\n</ul>\n<ol style="list-style-type: upper-roman;">\n<li><span style="font-size: 12pt;">Setter Injection</span></li>\n<li><span style="font-size: 16px;">Constuctor Injection</span></li>\n<li><span style="font-size: 16px;">Method Injection</span></li>\n</ol>\n<div><span style="font-size: 16px;">&nbsp;</span></div>\n<ul style="list-style-type: disc;">\n<li><span style="font-size: 12pt;"><b>Spring DI 컨테이너</b></span></li>\n</ul>\n<ol style="list-style-type: upper-roman;">\n<li><span style="font-size: 12pt;">spring DI 컨테이너가 관리하는 객체를 Bean이라고 하며 이 빈들을 관리한다는 의미로 컨테이너를 빈 팩토리라고 부른다.&nbsp;</span></li>\n<li><span style="font-size: 12pt;">빈팩토리는&nbsp;객체 등록, 생성, 조회, 반환을 관리한다.</span></li>\n<li><span style="font-size: 12pt;">보통은 빈팩토리를 바로 사용하지 않고 Application Context를 주로 사용한다.&nbsp;</span></li>\n</ol>\n<div>&nbsp;</div>\n<ul style="list-style-type: disc;">\n<li><span style="font-size: 12pt;"><b>Applcation Context</b></span></li>\n</ul>\n<ol style="list-style-type: upper-roman;">\n<li><span style="font-size: 12pt;">Bean을 등록, 생성, 조회, 반환 관리하는 기능은 BeanFactory와 같다.</span></li>\n</ol>\n<ul style="list-style-type: disc;">\n<li><span style="font-size: 16px;">@Component : 스프링프레임워크에게 너가 관리해야 하는 빈임을 알려줌.</span></li>\n<li><span style="font-size: 16px;">@Autowired : 스프링프레임워크에게 타입에 맞는 것을 찾아서 연결시켜달라는 것을 요청.</span></li>\n</ul>\n<div><span style="font-size: 16px;">&nbsp;</span></div>\n<div><span style="font-size: 16px;">&nbsp;</span></div>\n<div>\n<p><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;"><b><span style="font-size: 18pt;">디자인 패턴 (Design Pattern)</span></b></span></p>\n<p><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">절차형 언어에서 객체지향 언어로 넘어오면서 설계의 중요성이 커졌습니다. 객체지향은 객체들이 서로 메시지를 주고 받고 서로를 사용하면서 작업을 수행하기 때문에 객체를 어떻게 설정하고 객체 간 관계를 어떻게 정할 것인지, 이런 설계 작업이 핵심적으로 중요해졌습니다.</span></p>\n<p style="margin: 1.7em 0px; padding: 0px; border: 0px; outline: 0px; font-family: \'Noto Sans KR\', sans-serif; font-size: 16px; vertical-align: baseline; color: #555555;"><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">객체지향을 처음 배우는 사람들에게 이런 설계 개념을 설명하기 위해서 기존 개발 건 중에 설계가 잘 된 케이스들을 뽑아서 가르치기 시작했습니다. 이런 케이스들을 이름을 붙이고 목적과 용도, 그리고 구현 방법을 잘 정리해놓은 것이 바로</span><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">&nbsp;</span><b><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">디자인 패턴</span></b><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">&nbsp;</span><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">입니다. 그래서 아무렇게나 설계하는 것이 아니라 필요한 디자인 패턴을 참고해서 설계하면 효율적으로 설계할 수가 있게 되었죠.</span></p>\n<p><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;"><b><span style="font-size: 18pt;">&nbsp;</span></b></span></p>\n<p><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;"><b><span style="font-size: 18pt;">라이브러리 (Library)</span></b></span></p>\n<p><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">라이브러리는 어떠한 기능을 다른 사람들도 사용할 수 있도록 만들어 놓은 것을 말합니다. 예를 들어, 내가 만드는 애플리케이션 안에 이미지 변환 기능이 필요하다고 합시다. 그러면 이미지 변환 기능이 필요한 사람들은 모두 기능을 각자 구현해야곘죠. 하지만 그렇게 하지 않고 이미지 변환 기능을 다른 사람들도 소스 안에서 사용할 수 있도록</span><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">&nbsp;</span><code style="margin: 0px 2px; padding: 3px 5px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: \'IBM Plex Mono\', NanumSquareRound, Consolas; font-size: 0.8em; vertical-align: baseline; color: #990000; border-radius: 2px; background-color: #f8f8f8;"><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">jar</span></code><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">&nbsp;</span><span style="font-family: \'맑은 고딕\', sans-serif; font-size: 12pt;">형태로 묶어서 제공하는 것이 바로 라이브러리입니다.</span></p>\n</div>\n<div><span style="font-size: 16px;">&nbsp;</span></div>\n<div>&nbsp;</div>\n<div>\n<p><span style="font-family: \'맑은 고딕\', sans-serif;"><b><span style="font-size: 18pt;">프레임워크 = 디자인 패턴 + 라이브러리</span></b></span></p>\n<p><span style="font-family: \'맑은 고딕\', sans-serif;">프레임워크란 이름에서부터 알 수 있듯이 애플리케이션을 개발할 때 사용하는 일종의</span><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><b><span style="font-family: \'맑은 고딕\', sans-serif;">틀</span></b><span style="font-family: \'맑은 고딕\', sans-serif;">을 말합니다. 앞서 말한 디자인패턴과 라이브러리들을 모아서 프로그램 형태로 만들어놓은 겁니다. 그래서 프레임워크를 사용하면 여러가지 유용한 기능을 통해 개발자는 구현해야 하는 핵심 로직에 집중할 수가 있습니다.</span></p>\n</div>\n<div><span style="font-size: 16px;">&nbsp;</span></div>\n<div>\n<p><b><span style="font-size: 18pt;">스프링 핵심 기능</span></b></p>\n<p><span style="font-family: \'맑은 고딕\', sans-serif;">스프링의 핵심 기능은 다음과 같습니다. 각각에 대해서 설명하기에는 양이 너무 방대하니 자세한 내용은 다른 포스팅을 통해서 하나씩 알아보기로 하죠.</span></p>\n<ul style="margin: 1.7em 0px; padding: 0px; border: 0px; outline: 0px; font-family: \'Noto Sans KR\', sans-serif; font-size: 16px; vertical-align: baseline; list-style-position: inside; list-style-image: initial; line-height: 1.7em; color: #555555;">\n<li style="margin: 0px; padding: 0px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; vertical-align: baseline;"><span style="font-family: \'맑은 고딕\', sans-serif;">의존 주입 (</span><i><span style="font-family: \'맑은 고딕\', sans-serif;">Dependency Injection</span></i><span style="font-family: \'맑은 고딕\', sans-serif;">)</span></li>\n<li style="margin: 0px; padding: 0px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; vertical-align: baseline;"><span style="font-family: \'맑은 고딕\', sans-serif;">관점 지향 프로그래밍 (</span><i><span style="font-family: \'맑은 고딕\', sans-serif;">AOP; Aspect-Oriented Programming</span></i><span style="font-family: \'맑은 고딕\', sans-serif;">)</span></li>\n<li style="margin: 0px; padding: 0px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; vertical-align: baseline;"><span style="font-family: \'맑은 고딕\', sans-serif;">스프링 MVC 웹 애플리케이션과 RESTful 웹 서비스 프레임워크 (</span><i><span style="font-family: \'맑은 고딕\', sans-serif;">Spring MVC web application and RESTful web service framework</span></i><span style="font-family: \'맑은 고딕\', sans-serif;">)</span></li>\n<li style="margin: 0px; padding: 0px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; vertical-align: baseline;"><span style="font-family: \'맑은 고딕\', sans-serif;">JDBC, JPA, JMS 지원</span></li>\n</ul>\n</div>\n<div><span style="font-size: 16px;">&nbsp;</span></div>\n<div><figure class="imageblock alignCenter" width="780" height="545" data-origin-width="780" data-origin-height="545" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/99783C3D5C98BA4319" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/99783C3D5C98BA4319" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99783C3D5C98BA4319" width="780" height="545" data-origin-width="780" data-origin-height="545" data-ke-mobilestyle="widthContent"></span></figure>\n<p>&nbsp;</p>\n</div>\n<div>&nbsp;</div>\n<p>&nbsp;<b>Spring Legacy, Spring Boot 차이점</b></p>\n<p style="margin-left: 2em;"><b>&nbsp;</b><span style="font-size: 12pt;">&nbsp;스프링</span><span style="font-size: 12pt;">부트 같은 경우 웹 컨테이너 (톰캣)을 내장하고 있고 최소한의 설정으로 쉽게 Spring Application을 만들기 위한 목적으로 설계된 프레임워크이라 할 수 있다. 그렇기 때문에 Spring boot로 Set up 할 경우 편리하게 Dependency 문제가 해결되고, 빠르게 웹 어플리케이션을 만들 수 있는 장점이 있다.&nbsp;</span></p>\n<ul style="margin: 1.7em 0px; padding: 0px; border: 0px; outline: 0px; font-size: 16px; vertical-align: baseline; list-style-position: inside; list-style-image: initial; line-height: 1.7em; color: #555555;">\n<ul style="font-family: \'Noto Sans KR\', sans-serif; margin-top: 1.7em; margin-right: 0px; margin-bottom: 1.7em; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; border: 0px; outline: 0px; font-size: 16px; vertical-align: baseline; list-style-position: inside; list-style-image: initial; line-height: 1.7em; color: #555555;">\n<li style="margin: 0px; padding: 0px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; vertical-align: baseline;"><span style="font-family: \'맑은 고딕\', sans-serif;">내장 서버:&nbsp;</span><code style="margin: 0px 2px; padding: 3px 5px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: \'IBM Plex Mono\', NanumSquareRound, Consolas; font-size: 0.8em; vertical-align: baseline; color: #990000; border-radius: 2px; background-color: #f8f8f8;"><span style="font-family: \'맑은 고딕\', sans-serif;">WAR</span></code><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><span style="font-family: \'맑은 고딕\', sans-serif;">파일을 배포할 필요 없이 내장된</span><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><code style="margin: 0px 2px; padding: 3px 5px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: \'IBM Plex Mono\', NanumSquareRound, Consolas; font-size: 0.8em; vertical-align: baseline; color: #990000; border-radius: 2px; background-color: #f8f8f8;"><span style="font-family: \'맑은 고딕\', sans-serif;">Tomcat</span></code><span style="font-family: \'맑은 고딕\', sans-serif;">,</span><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><code style="margin: 0px 2px; padding: 3px 5px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: \'IBM Plex Mono\', NanumSquareRound, Consolas; font-size: 0.8em; vertical-align: baseline; color: #990000; border-radius: 2px; background-color: #f8f8f8;"><span style="font-family: \'맑은 고딕\', sans-serif;">Jetty</span></code><span style="font-family: \'맑은 고딕\', sans-serif;">,</span><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><code style="margin: 0px 2px; padding: 3px 5px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: \'IBM Plex Mono\', NanumSquareRound, Consolas; font-size: 0.8em; vertical-align: baseline; color: #990000; border-radius: 2px; background-color: #f8f8f8;"><span style="font-family: \'맑은 고딕\', sans-serif;">Unertow</span></code><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><span style="font-family: \'맑은 고딕\', sans-serif;">를 이용해 실행할 수 있습니다.</span></li>\n<li style="margin: 0px; padding: 0px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; vertical-align: baseline;"><span style="font-family: \'맑은 고딕\', sans-serif;">간단한 라이브러리 관리: 많이 사용하는 라이브러리를 모아놓은 스타터 (Starter)</span><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><code style="margin: 0px 2px; padding: 3px 5px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: \'IBM Plex Mono\', NanumSquareRound, Consolas; font-size: 0.8em; vertical-align: baseline; color: #990000; border-radius: 2px; background-color: #f8f8f8;"><span style="font-family: \'맑은 고딕\', sans-serif;">POM</span></code><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><span style="font-family: \'맑은 고딕\', sans-serif;">파일로 메이븐 설정이 쉬워집니다.</span></li>\n<li style="margin: 0px; padding: 0px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: inherit; vertical-align: baseline;"><span style="font-family: \'맑은 고딕\', sans-serif;">자동 설정: 더 이상</span><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><code style="margin: 0px 2px; padding: 3px 5px; border: 0px; outline: 0px; font-weight: inherit; font-style: inherit; font-family: \'IBM Plex Mono\', NanumSquareRound, Consolas; font-size: 0.8em; vertical-align: baseline; color: #990000; border-radius: 2px; background-color: #f8f8f8;"><span style="font-family: \'맑은 고딕\', sans-serif;">XML</span></code><span style="font-family: \'맑은 고딕\', sans-serif;">&nbsp;</span><span style="font-family: \'맑은 고딕\', sans-serif;">설정이 필요하지 않습니다.</span></li>\n</ul>\n</ul>\n<div><span style="color: #555555;"><span style="font-size: 16px;">&nbsp;</span></span></div>\n</div>\n<div><span style="color: #555555;"><span style="font-size: 16px;">&nbsp;</span></span></div>\n<div><figure class="imageblock alignCenter" width="796" height="731" data-origin-width="796" data-origin-height="731" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/9966D2505C98BD6126" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/9966D2505C98BD6126" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9966D2505C98BD6126" width="796" height="731" data-origin-width="796" data-origin-height="731" data-ke-mobilestyle="widthContent"></span></figure>\n<p style="text-align: center; clear: none; float: none;">&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<span style="color: #555555;"><span style="font-size: 16px;"><br></span></span></div>\n<p></p><figure class="imageblock alignCenter" width="819" height="479" data-origin-width="819" data-origin-height="479" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/99A9B64A5C98BDB112" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/99A9B64A5C98BDB112" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99A9B64A5C98BDB112" width="819" height="479" data-origin-width="819" data-origin-height="479" data-ke-mobilestyle="widthContent"></span></figure><p></p>\n<p style="margin-left: 2em;">&nbsp;</p>\n<p style="margin-left: 2em;">&nbsp;</p>\n<p style="margin-left: 2em;">&nbsp;</p>\n<p style="margin-left: 2em;">&nbsp;</p>\n<p style="margin-left: 2em;"><span style="font-size: 18pt;"><b>JPA vs Mybatis</b></span></p>\n<p></p><figure class="imageblock alignCenter" width="816" height="795" data-origin-width="816" data-origin-height="795" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/99B8DE4A5C98BE6D27" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/99B8DE4A5C98BE6D27" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99B8DE4A5C98BE6D27" width="816" height="795" data-origin-width="816" data-origin-height="795" data-ke-mobilestyle="widthContent"></span></figure><p></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p></p><figure class="imageblock alignCenter" width="783" height="692" data-origin-width="783" data-origin-height="692" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/998A784B5C98BF091F" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/998A784B5C98BF091F" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F998A784B5C98BF091F" width="783" height="692" data-origin-width="783" data-origin-height="692" data-ke-mobilestyle="widthContent"></span></figure><p></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p></p><figure class="imageblock alignCenter" width="815" height="800" data-origin-width="815" data-origin-height="800" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/99EAD44F5C98BF3315" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/99EAD44F5C98BF3315" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99EAD44F5C98BF3315" width="815" height="800" data-origin-width="815" data-origin-height="800" data-ke-mobilestyle="widthContent"></span></figure><p></p>\n<p>&nbsp;</p>\n<p></p><figure class="imageblock alignCenter" width="776" height="725" data-origin-width="776" data-origin-height="725" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/99D9CD465C98BF5B1C" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/99D9CD465C98BF5B1C" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99D9CD465C98BF5B1C" width="776" height="725" data-origin-width="776" data-origin-height="725" data-ke-mobilestyle="widthContent"></span></figure><p></p>\n<p>&nbsp;</p>\n<p></p><figure class="imageblock alignCenter" width="860" height="880" data-origin-width="860" data-origin-height="880" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/9929EC485C98BF882B" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/9929EC485C98BF882B" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9929EC485C98BF882B" width="860" height="880" data-origin-width="860" data-origin-height="880" data-ke-mobilestyle="widthContent"></span></figure><p></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p></p><figure class="imageblock alignCenter" width="780" height="864" data-origin-width="780" data-origin-height="864" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/998C7C465C98BFC52B" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/998C7C465C98BFC52B" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F998C7C465C98BFC52B" width="780" height="864" data-origin-width="780" data-origin-height="864" data-ke-mobilestyle="widthContent"></span></figure><p></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p></p><figure class="imageblock alignCenter" width="760" height="116" data-origin-width="760" data-origin-height="116" data-ke-mobilestyle="widthContent"><span data-url="https://t1.daumcdn.net/cfile/tistory/9981F24F5C98BFE31A" data-lightbox="lightbox" data-alt=""><img src="https://t1.daumcdn.net/cfile/tistory/9981F24F5C98BFE31A" srcset="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9981F24F5C98BFE31A" width="760" height="116" data-origin-width="760" data-origin-height="116" data-ke-mobilestyle="widthContent"></span></figure><p></p></div>'},{key:"4",sort:4,tags:["자바","스프링","HTTP","RestFul"],title:"RestFul",content:'\t\t\t\t\t\t<div class="entry-content">\n\t\t\t\t\t\t\t<div class="tt_article_useless_p_margin"><p><b style="font-size: 12pt;"><span style="font-size: 18pt; color: rgb(93, 93, 93);">Rest란?</span></b></p><p><br></p><ul style="list-style-type: disc;"><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">자원 (Resource) 을 이름으로 구분하여 해당 자원의 상태와 정보를 주고 받는 모든 것을 의미한다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍쳐 스타일이다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">HTTP URI를 통해 자원을 명시하고, HTTP 메서드 (POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Opertation을 적용하는 것을 의미한다.&nbsp;</span></li></ul><p><br></p><p><br></p><p><span style="font-size: 12pt;"><b><span style="font-size: 18pt; color: rgb(93, 93, 93);">HTTP란?</span></b></span></p><p><br></p><ul style="list-style-type: disc;"><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">HyperText Transfer Protocol의 약자로 인터넷 상에서 데이터를 주고 받기 위한 서버/클라이언트 모델을 따르는 프로토콜이다. 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">HTTP는 어느 종류의 데이터든지 전송할 수 있다. HTML뿐만아니라 이미지, 동영상등 종류 전송이 가능하다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">이름그대로 하이퍼텍스트를 기반으로 데이터를 전송하겠다는 뜻이다. 간단히 말하면 링크기반으로 데이터에 접속하겠다는 의미이다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">서버/클라이언트 모델 방식에 따르며 클라이언트 Request를 보내면 서버는 요청을 처리해 Response한다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">클라이언트 : 서버에 요청하는 클라이언트 소프트웨어가 설치된 컴퓨터, Chrome 등 클라이언트 소프트웨어를 이용한다. 클라이언트는 URL을 이용해서 접속하고, 데이터를 요청할 수 있다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">서버 : 클라이언트의 요청을 받아서, 요청을 해석하고 응답을 하는 소프트웨어가 설치된 컴퓨터, Apache 등의 서버 소프트웨어이다.&nbsp;</span></li></ul><p><br></p><p><br></p><p><span style="font-size: 18pt;"><b><span style="color: rgb(93, 93, 93); font-size: 18pt;">자원이란?</span></b></span></p><ul style="list-style-type: disc;"><li><span style="font-size: 12pt; text-align: justify; color: rgb(93, 93, 93);">자원 : 해당 소프트웨어가 관리하는 모든 것.&nbsp; &nbsp; ex) 문서, 그림, 데이터, 해당 소프트웨어 자체 등등.</span></li><li><span style="font-size: 12pt; text-align: justify; color: rgb(93, 93, 93);">자원의 표현 : 그 자원을 표현하기 위한 이름.&nbsp; &nbsp; ex) DB의 학생정보가 자원일 때, \'students\'를 자원의 표현으로 정한다.</span></li></ul><div style="text-align: justify;"><br></div><div style="text-align: justify;"><br></div><div style="text-align: justify;"><span style="font-size: 12pt;"><b><span style="font-size: 18pt; color: rgb(93, 93, 93);">상태전달이란?</span></b></span></div><div style="text-align: justify;"><span style="font-size: 12pt;"><br></span></div><div style="text-align: justify;"><span style="font-size: 12pt; color: rgb(93, 93, 93);">- 데이터가 요청되어지는 시점에서 자원의 상태(정보)를 전달한다.</span></div><div style="text-align: justify;"><span style="font-size: 12pt; color: rgb(93, 93, 93);">-&nbsp;</span><span style="font-size: 12pt; color: rgb(93, 93, 93);">JSON 혹은 XML을 통해 데이터를 주고받는 것이 일반적이다.</span></div><p></p><p></p><div style="text-align: justify;"><br></div><div style="text-align: justify;"><br></div><div style="text-align: justify;"><span style="font-size: 12pt;"><b><span style="font-size: 18pt; color: rgb(93, 93, 93);">Rest의 장단점</span></b></span></div><div style="text-align: justify;"><br></div><div style="text-align: justify;"><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">- 장점</span></b></span></div><div style="text-align: justify;"><span style="font-size: 12pt; color: rgb(93, 93, 93);">* HTTP 프로토콜의 인프라를 그대로 사용하므로 REST API 사용을 위한 별도의 인프라를 구축할 필요가 없다</span><span style="font-size: 12pt; color: rgb(93, 93, 93);">.</span></div><div style="text-align: justify;"><span style="font-size: 12pt; color: rgb(93, 93, 93);">* HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용 가능하다.</span></div><div style="text-align: justify;"><span style="font-size: 12pt; color: rgb(93, 93, 93);">* 서버와 클라이언트의 역할을 명확하게 분리한다.</span></div><div style="text-align: justify;"><span style="font-size: 12pt;"><b><br></b></span></div><div style="text-align: justify;"><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">- 단점</span></b></span></div><p></p><div style="text-align: justify;"><span style="font-size: 12pt; color: rgb(93, 93, 93);">* HTTP 메서드의 한계에 묶인다.</span></div><p></p><p></p><div style="text-align: justify;"><span style="font-size: 12pt; color: rgb(93, 93, 93);">* REST API는 HTTP 메서드를 이용하여 URI에 대한 행위를 정의한다. (get, post, put, delete)</span></div><p></p><p></p><div style="text-align: justify;"><span style="font-size: 12pt; color: rgb(93, 93, 93);">* 표준이 없어서 관리하기 어렵다. REST API는 API 설계 가이드일 뿐이지 명시적인 표준이 아니다. 따라서 관리가 어렵고, 공식화된 API 디자인 가이드가 없다.</span></div><p></p><div style="text-align: justify;"><p></p><p></p><p></p><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;"><br></span></div><p></p><p></p><p></p><div><span style="font-size: 18pt;"><b><span style="color: rgb(93, 93, 93); font-size: 18pt;">REST가 필요한 이유</span></b></span></div><ul style="list-style-type: disc;"><ul style="list-style-type: disc;"><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">애플리케이션 분리 및 통합.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">다양한 클라이언트의 등장.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">다양한 브라우저와 안드로이드폰, 아이폰과 같은 모바일 디바이스에서도 통신할 수 있다.</span></li></ul></ul><div><br></div><div><br></div><div><span style="font-size: 12pt;"><b><span style="font-size: 18pt; color: rgb(93, 93, 93);">REST 구성요소</span></b></span></div><div><br></div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">- 자원 (Resource) : URI</span></b></span></div><div><ul><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">&nbsp;모든 자원에 고유한 ID가 존재하고, 이 자원은 Server에 존재한다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">&nbsp;자원을 구별하는 ID는 HTTP URI 다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">&nbsp;Client는 URL를 이용해서 자원을 지정하고 해당 자원의 상태에 대한 조작을 Server에 요청한다.</span></li></ul></ul><div><span style="font-size: 12pt; color: rgb(93, 93, 93);">&nbsp;</span></div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">- 행위 (Verb) : HTTP Method</span></b></span></div></div></div><ul style="text-align: justify;"><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">HTTP 프로토콜의 메서드를 사용한다.&nbsp;</span></li></ul><div style="text-align: justify;"><br></div><div style="text-align: justify;"><br></div><div style="text-align: justify;"><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">- 표현 (Representation of Resource)</span></b></span></div><div style="text-align: justify;"><ul><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">Client가 자원의 상태에 대해 조작을 요청하면 Server는 이에 대한 적절한 응답을 보낸다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">Rest에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태의 표현으로 나타내어질 수 있다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">JSON, XML이 가장 일반적이다.&nbsp;</span></li></ul></ul><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;"><br></span></div><div><span style="font-size: 16px;"><b style=""><span style="font-size: 18pt; color: rgb(93, 93, 93);">REST 특징</span></b></span></div><div><b><br></b></div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">1. Server-Client 구조</span></b></span></div><div><ul><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">자원이 있는 쪽이 Server, 자원을 요청하는 쪽이 Client가 된다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">REST Server : API를 제공하고 비즈니스 로직 처리 및 저장을 책임진다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">Client : 사용자 인증이나 context (세션, 로그인 정보) 등을 직접 관리하고 책임</span><span style="font-size: 12pt; color: rgb(93, 93, 93);">진다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">서로 간 의존성이 줄어든다.</span></li></ul></ul><div><br></div></div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">2. Stateless (무상태)</span></b></span></div><div style="margin-left: 2em;"><br></div><div style="margin-left: 2em;"><span style="font-size: 12pt; color: rgb(93, 93, 93);">이전 요청과 각각 무관한 요청을 독립적으로 처리한다는 의미. server에 client와 server의 연속된 동작 상태정보를 저장하지 않는 형태. &lt;-&gt; stateful</span></div><div><ul><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">HTTP 프로토콜은 Stateless Protocol 이므로 REST 역시 무상태성을 갖는다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">Client의 context를 Server에 저장하지 않는다. 즉, 세션과 쿠키와 같은 context정보를 신경쓰지 않아도 되므로 구현이 단순해진다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">Server라는 각각의 요청을 완전히 별개의 것으로 인식하고 처리한다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">서로 간 의존성이 줄어든다.&nbsp;</span></li></ul><ol style="list-style-type: upper-alpha;"><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">각 API 서버는 Client의 요청만을 단순 처리한다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">즉, 이전 요청이 다음 요청의 처리에 연관되어서는 안된다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">물론 이전 요청이 DB를 수정하여 DB에 의해 바뀌는 것을 허용한다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">Server의 처리 방식에 일관성을 부여하고 부담이 줄어들며, 서비스의 자유도가 높아진다.&nbsp; &nbsp;&nbsp;</span></li></ol></ul><div><b><br></b></div></div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">3. Cacheable (캐시 처리 가능)</span></b></span></div><div><ul><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">웹 표준 HTTP 프로토콜을 그대로 사용하므로 웹에서 사용하는 기존의 인프라를 그대로 활용할 수 있다. 즉, HTTP가 가진 가장 강력한 특징 중 하나인 캐싱 기능을 적용할 수 있다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">대량의 요청을 효율적으로 처리하기 위해 캐시가 요구된다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">캐시사용을 통해 응답시간이 빨라지고 REST Server 트랜잭션이 발생하지 않기 때문에 전체 응답시간, 성능, 서버의 자원 이용률을 향상시킬 수 있다.</span></li></ul></ul><div><br></div></div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">4. Layerd System (계층화)</span></b></span></div><div><ul><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">Client는 REST API Server만 호출한다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">REST Server는 다중 계층으로 구성될 수 있다. API Server는 순수 비즈니스 로직을 수행하고 그 앞단에 보안, 로드밸런싱, 암호화, 사용자 인증등을 추가하여 구조상의 유연성을 줄 수 있다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">로드밸런싱, 공유 캐시 등을 통해 확장성과 보안성을 향상시킬 수 있다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">PROXY, 게이트웨이 같은 네트워크 기반의 중간 매체를 사용할 수 있다.&nbsp;</span><span style="font-size: 12pt; color: rgb(93, 93, 93);">&nbsp;</span></li></ul></ul><div><br></div></div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">5. Code-On-Demand (Optional)</span></b></span></div><div><ul><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">Server로 부터 스크립트를 받아서 Client에서 실행한다.</span></li></ul></ul><div><span style="font-size: 16px;"><br></span></div></div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">6. Uniform Interface (인터페이스 일관성)</span></b></span></div><div><ul><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">URI로 지정한 Resource에 대한 조작을 통일되고 한정적인 인터페이스로 수행한다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">HTTP 표준 프로토콜에 따르는 모든 플랫폼에서 사용 가능하다. 특정 언어나 기술에 종속되지 않는다.&nbsp;</span></li></ul></ul><div><span style="font-size: 16px;"><br></span></div></div><div><span style="font-size: 16px;"><br></span></div><div><div><span style="font-size: 16px;"><b><span style="font-size: 18pt; color: rgb(93, 93, 93);">REST API</span></b></span></div><div><b><br></b></div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">1. API (Application Programming Interface)란?</span></b></span></div></div><div><br></div><div><span style="font-size: 12pt; color: rgb(93, 93, 93);">&nbsp;데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환 가능하도록 한 것. REST API는 REST 기반의 API를 말한다.&nbsp;</span></div><div><br></div><div><br></div><div><div><span style="font-size: 12pt;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">2.&nbsp;REST API 특징</span></b></span></div><div><ul><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.&nbsp;</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">즉, REST API를 제작하면 델파이 클라이언트 뿐 아니라, 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다.&nbsp;</span></li></ul></ul><div><br></div></div></div><div><b><span style="font-size: 12pt; color: rgb(93, 93, 93);">3. 응답상태코드</span></b></div><div><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">1XX : 리퀘스트를 받고 처리중에 있음.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">2XX : 리퀘스트를 정상적으로 처리함.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">3XX : 리퀘스트 완료를 위해 추가 동작이 필요함.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">4XX : 클라이언트의 잘못된 요청으로 오류발생.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">5XX : 서버쪽 오류로 인한 상태코드.</span></li></ul><div><span style="font-size: 16px;"><br></span></div></div><div><span style="font-size: 16px;"><br></span></div><div><div><span style="font-size: 16px;"><b><span style="font-size: 18pt; color: rgb(93, 93, 93);">RESTful이란?</span></b></span></div><div><b><br></b></div><ul style="list-style-type: disc;"><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어. \'REST API\'를 제공하는 웹서비스를 \'RESTful\' 하다고 할 수 있다.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">REST 원리를 따르는 시스템.</span></li></ul><div><span style="font-size: 16px;"><br></span></div></div><div><span style="font-size: 16px;"><b><span style="color: rgb(93, 93, 93); font-size: 12pt;">1. RESTful 목적</span></b></span></div><div><ul><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것.</span></li><li><span style="font-size: 12pt; color: rgb(93, 93, 93);">RESTful한 API를 구현하는 근본적인 목적이 성능 향상에 있는 것이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것이 주 동기이니, 성능이 중요한 상황에서 굳이 RESTful한 API를 구현할 필요는 없다.&nbsp;</span></li></ul></div><div><span style="font-size: 16px;"><br></span></div></div></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\n\n\t\t\t\t\t\t<script type="text/javascript">loadedComments[5]=true;findFragmentAndHighlight(5)<\/script>\n\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t</div>'},{key:"5",sort:5,tags:["자바","스프링"],title:"객체지향 정리",content:'<div class="entry-content">\n\t\t\t\t\t\t\t<div class="tt_article_useless_p_margin"><p><br></p><div class="appbar" id="appbar" style="min-width: 1100px; background-image: initial; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial; box-sizing: border-box; width: 1100px; color: rgb(34, 34, 34); font-family: &quot;Apple SD Gothic Neo&quot;, arial, sans-serif; font-size: small;"><div></div></div><div class="mw" id="ucs" style="max-width: 1197px; color: rgb(34, 34, 34); font-family: &quot;Apple SD Gothic Neo&quot;, arial, sans-serif; font-size: small;"></div><div id="ataw" style="color: rgb(34, 34, 34); font-family: &quot;Apple SD Gothic Neo&quot;, arial, sans-serif; font-size: small;"><div id="atvcap"></div></div><div class="mw" style="max-width: 1197px; color: rgb(34, 34, 34); font-family: &quot;Apple SD Gothic Neo&quot;, arial, sans-serif; font-size: small;"><div id="rcnt" style="margin-top: 0px; clear: both; position: relative; zoom: 1;"><div id="bcenter"><div class="col" style="float: left; width: 0px;"></div></div><div class="col" style="float: left; width: 0px;"><div id="center_col" style="position: relative; margin-left: 150px; margin-right: 249px; clear: both; width: 632px;"><div id="taw"><div></div><div style="padding: 0px 20px;"><div class="med" style="font-size: medium; margin: 0px; padding: 0px;"></div></div><div id="tvcap"></div></div><div class="med" id="res" role="main" style="font-size: medium; margin: 0px; padding: 0px 20px; line-height: 1.3; border: 0px;"><div id="topstuff"></div><div id="search"><div data-ved="0ahUKEwiUoMHOwZfhAhW0w4sBHe8sAXEQGggp"><h1 class="bNg8Rb" style="margin: 0px; padding: 0px; font-size: small; font-weight: normal; clip: rect(1px, 1px, 1px, 1px); height: 1px; overflow: hidden; position: absolute; white-space: nowrap; width: 1px; z-index: -1000;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">검색결과</span></h1><div data-async-context="query:%EB%8B%B9%EA%B5%AC%EC%9E%A5%20%EC%9D%B4%EB%AA%A8%ED%8B%B0%EC%BD%98" id="ires" style="margin-top: 6px;"><div eid="ocGVXNTLFbSHr7wP79mEiAc" id="rso"><div class="bkWMgd"><h2 class="bNg8Rb" style="clip: rect(1px, 1px, 1px, 1px); height: 1px; margin: 0px; overflow: hidden; padding: 0px; position: absolute; white-space: nowrap; width: 1px; z-index: -1000;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">웹 검색결과</span></h2><div class="srg"><div class="g" style="line-height: 1.3; font-size: small; margin-top: 0px; margin-bottom: 30px;"><div data-hveid="CAIQAA" data-ved="2ahUKEwiUoMHOwZfhAhW0w4sBHe8sAXEQFSgAMAB6BAgCEAA"><div class="rc" style="position: relative;"><div class="r" style="margin: 0px; line-height: 1.54;"><br></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div><p><b><span style="font-size: 18pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(255, 94, 0); font-size: 24pt;">객체지향프로그래밍</span></span></b></p><p><br></p><p><br></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">1.&nbsp;객체지향</span></b><span style="color: rgb(255, 94, 0);">&nbsp;</span></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0);">&nbsp;<span style="font-size: 12pt;">실제사물들의 속성과 기능들을 프로그램 내에 변수와 메서드로 정의하여 코드간의 관계를 맺어주는 것.</span></span></span></p><p style="margin-left: 4em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);"><b><span style="color: rgb(0, 0, 0);">1.1) OOP :</span></b><span style="color: rgb(0, 0, 0);"> 데이터를 객체로 취급하여 프로그램에 반영한 것이며, 순차적으로 프로그램이 동작하는 기존의 것들과는 다르게 객체의 상호작용을 통해 프로그램이 동작하는 것. 캡슐화, 다형성, 상속을 이용하여 코드의 재사용을 증가시키고, 유지보수를 감소시키는 장점을 얻기 위해서 객체들을 연결시켜 프로그래밍하는 기법.</span></span></p><p style="margin-left: 6em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 6em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);"><b><span style="color: rgb(0, 0, 0);">1.1.1) 캡슐화 :</span></b><span style="color: rgb(0, 0, 0);"> 외부에서 특정 속성이나 메서드를 사용자가 사용할 수 없도록 숨겨놓는 것.</span></span></p><p style="margin-left: 8em;"><span style="color: rgb(0, 0, 0); font-family: &quot;Noto Sans&quot;, sans-serif; font-size: 12pt;">ㆍ객체의 필드(속성), 메서드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것.</span></p><p style="margin-left: 8em;"><span style="color: rgb(0, 0, 0); font-family: &quot;Noto Sans&quot;, sans-serif; font-size: 12pt;">ㆍ외부 객체는 객체 내부의 구조를 얻지 못하며 객체가 노출해서 제공하는 필드와 메서드만 이용할 수&nbsp; &nbsp; &nbsp; &nbsp;있다.</span></p><p style="margin-left: 8em;"><span style="color: rgb(0, 0, 0); font-family: &quot;Noto Sans&quot;, sans-serif; font-size: 12pt;">ㆍ필드와 메서드를 캡슐화 하여 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록&nbsp; &nbsp; &nbsp;하는 데 있다.</span></p><p style="margin-left: 8em;"><span style="color: rgb(0, 0, 0); font-family: &quot;Noto Sans&quot;, sans-serif; font-size: 12pt;">ㆍ자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결정하기 위해 접근 제한자를 사용한다.&nbsp;</span></p><p style="margin-left: 6em;"><span style="font-size: 18.6667px;"><br></span></p><p style="margin-left: 6em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);"><b><span style="color: rgb(0, 0, 0);">1.1.2) 상속 :</span></b><span style="color: rgb(0, 0, 0);"> 현실 세계에서 상속이란 부모가 자식에게 물려주는 행위, 부모가 자식을 선택해서물려주는 행위지만, 객체지향 프로그래밍에서의 상속은 현실 세계와 반대로 자식이 부모를 선택해서 물려받는 것을 말한다.</span></span></p><p style="margin-left: 8em;"><span style="color: rgb(0, 0, 0); font-family: &quot;Noto Sans&quot;, sans-serif; font-size: 12pt;">ㆍ자식 클래스가 부모 클래스의 멤버를 물려받음.</span></p><p style="margin-left: 8em;"><span style="color: rgb(0, 0, 0); font-family: &quot;Noto Sans&quot;, sans-serif; font-size: 12pt;">ㆍ자식클래스가 부모클래스를 선택해서 물려받음.</span></p><p style="margin-left: 8em;"><span style="color: rgb(0, 0, 0); font-family: &quot;Noto Sans&quot;, sans-serif; font-size: 12pt;">ㆍ부모클래스의 재사용을 통해 자식 클래스를 빨리 개발할 수 있으며, 이를 통해 반복된 코드의 중복을&nbsp;최소화하고 유지보수의 편리성을 제공하며 객체의 다형성을 구현할 수 있다.</span></p><p style="margin-left: 6em;"><span style="font-size: 18.6667px;"><br></span></p><p style="margin-left: 6em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);"><b><span style="color: rgb(0, 0, 0);">1.1.3</span></b></span><span style="font-size: 12pt; color: rgb(0, 0, 0);"><b><span style="color: rgb(0, 0, 0);">) 다형성 :</span></b><span style="color: rgb(0, 0, 0);"> 같은 타입이지만 실행결과가 다양한 객체를 대입하여 이용할 수 있는 성질을 말한다. 부모타입에는 모든 자식 객체가 대입될 수 있으며 자식타입은 부모 타입으로 자동 타입 변환이 된다.</span></span></p><p style="margin-left: 6em;"><br></p><p style="margin-left: 8em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">다형성은 객체를 부품화 시킬 수 있다. 예를 들어, 자동차란 객체가 있을 경우 자동차를 설계 할 때 타이어 부분에 사용된 부분을 아이어 타입이라고 가정하자. 자동차의 타이어 타입으로 한국타이어, 금호타이어가 있다고 한다면, 어떤 타이어를 사용하느냐에 따라 각 타이어의 성능은 다르게 나올 수 있다는 것이 다형성이라는 측면이다.</span></p><p style="margin-left: 10em;"><br></p><p style="margin-left: 8em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">한국타이어, 금호타이어는 자식 객체로써 객체를 부품화 시킬 수 있다. 자동차는 타이어 타입으로 한국타이어와 금호타이어를 사용하지만, 각 타이어의 성능은 다르게 나온다. =&gt; 다형성</span></p><p style="margin-left: 8em;"><br></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(0, 0, 0);">&nbsp; &nbsp;</span></b></span></p><p style="margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);"><b>1.2 객체지향의 장점 :</b>&nbsp;</span><span style="color: rgb(0, 0, 0); font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt;">프로그램의 유기적 운용을 가능하게한다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-family: &quot;Helvetica Neue&quot;, &quot;Apple SD Gothic Neo&quot;, 나눔고딕, NanumGothic, &quot;맑은 고딕&quot;, &quot;Malgun Gothic&quot;, 돋움, Dotum, sans-serif; font-size: 10pt;"><span style="font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt; color: rgb(0, 0, 0);">①</span><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">&nbsp;</span></span><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">코드의 재사용이 높다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">② 코드의 관리가 용이하다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">③ 코드의 중복을 제거하고 제어자와 메서드로 올바른 값을 유지하여 신뢰성높은 프로그래밍을 하게한다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">2. 클래스&nbsp;</span></b></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;한 객체를 생성하기 위한 설계도이자 데이터와 함수가 결합된 것. 객체의 모든 속성을 정의함으로써 관리를 편리하게 하고 새로운 함수를 정의하는 사용자 정의 함수이다.&nbsp;</span></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;"><br></span></span></p><p style="margin-left: 2em;"><br></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">3. 변수&nbsp;종류&nbsp;</span></b></span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">①</span><span style="color: rgb(0, 0, 0); font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt;">&nbsp; 인스턴스변수(iv) : 클래스 내 선언된 변수. 공유 또는 사용하기 위해 객체생성이 필요하다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">②&nbsp;&nbsp;클래스변수 (cv) : static으로 선언된 지역변수. 객체생성 없이 사용이 가능하다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">③&nbsp; 지역변수 (lv) : 메서드 내에서 선언된 변수. 메서드 종료시 소멸된다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">4. 메서드 종류</span></b></span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">①</span><span style="color: rgb(0, 0, 0); font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt;">&nbsp;&nbsp;인스턴스메서드(im) : iv를 사용하는 메서드. 호출 시 객체생성이 필요하다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">②&nbsp;</span><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">&nbsp;클래스메서드(cm) : static으로 선언된 메서드. iv를 사용하지 않는다. 객체생성 없이 호출 가능하다.</span></p><p style="margin-left: 4em;"><a href="https://myubuntu.tistory.com/entry/%EB%8B%B9%EA%B5%AC%EC%9E%A5-%EA%B8%B0%ED%98%B8%E2%80%BB%EC%9D%98-%EB%B9%84%ED%9A%A8%EC%9C%A8%EC%84%B1" ping="/url?sa=t&amp;source=web&amp;rct=j&amp;url=https://myubuntu.tistory.com/entry/%25EB%258B%25B9%25EA%25B5%25AC%25EC%259E%25A5-%25EA%25B8%25B0%25ED%2598%25B8%25E2%2580%25BB%25EC%259D%2598-%25EB%25B9%2584%25ED%259A%25A8%25EC%259C%25A8%25EC%2584%25B1&amp;ved=2ahUKEwiUoMHOwZfhAhW0w4sBHe8sAXEQFjAAegQIAhAB" style="color: rgb(102, 0, 153); font-family: &quot;Apple SD Gothic Neo&quot;, arial, sans-serif; font-size: small; cursor: pointer;"></a></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 4em;"><span style="font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt; color: rgb(0, 0, 0);">※ static메서드에서 인스턴스메서드 호출이 불가능한 이유 &nbsp;</span><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">&nbsp;</span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 6em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="font-size: 12pt; color: rgb(0, 0, 0);">static멤버부터 메모리에 적재되기 때문에 인스턴스메서드를 호출했을 때 객체생성여부를 알지 못한다. 즉, 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수 있고 객체가 없을 수 있다.&nbsp;</span><span style="font-size: 12pt; color: rgb(0, 0, 0);">&nbsp;</span></span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 6em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="font-size: 12pt; color: rgb(0, 0, 0);"><br></span></span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 4em;"><br></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">5. 오버로딩</span></b><span style="color: rgb(255, 0, 0);">&nbsp;</span></span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;같은 이름의 메서드로 중복정의 한 것. new성질&nbsp;- 새로운 메서드.</span></span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">- 조건</span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">①</span><span style="color: rgb(0, 0, 0); font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt;">&nbsp; 메서드명이 같다.</span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">②&nbsp; 매개변수 타입이 다르거나 갯수가 달라야한다.</span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">&nbsp;※&nbsp;&nbsp;</span><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">매개변수명과 리턴타입은 아무런 영향을 미치지 않는다.</span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">6. 오버라이딩</span></b><span style="color: rgb(255, 0, 0);">&nbsp;</span></span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0);">&nbsp;<span style="font-size: 12pt;">조상메서드를 자손에 맞게 변경하는 것. change성질&nbsp;- 메서드를 변경. (1.13 상속 참고)</span></span></span></p><p style="margin-top: 0px; margin-bottom: 0px; margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">- 조건</span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-family: &quot;Helvetica Neue&quot;, &quot;Apple SD Gothic Neo&quot;, 나눔고딕, NanumGothic, &quot;맑은 고딕&quot;, &quot;Malgun Gothic&quot;, 돋움, Dotum, sans-serif; font-size: 10pt;"><span style="font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt; color: rgb(0, 0, 0);">①</span><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">&nbsp;</span></span><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">선언부가 같다. (메서드명, 매개변수, 리턴타입)</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">② 자손메서드의 접근범위가&nbsp;조상메서드의 접근범위 보다 같거나 넓다. (자손메서드 &gt;= 조상메서드)</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">③ 조상메서드보다 많은 예외 선언을 허용하지 않는다. (자손메서드 &lt;= 조상메서드)</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">7. 가변인자</span></b></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;매개변수를 동적으로 지정하는 것.</span></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;"><br></span></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">8. 생성자</span></b></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;객체초기화 메서드. 인스턴스 변수를 초기화하기 위해 사용한다.&nbsp;</span></span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">- 조건</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">①</span><span style="color: rgb(0, 0, 0); font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt;">&nbsp;클래스 생성시 생성자가 존재하지 않으면 자동생성된다.&nbsp;</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">② 생성자명은 클래스명과 같다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">③ 리턴타입이 없다.(void)</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">9. this()</span></b></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;생성자에서 다른생성자를 호출할 때 사용한다.&nbsp;</span></span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">- 조건</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">① 생성자 이름으로 반드시 this()를 사용한다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">② 첫 줄에서 호출된다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 2em;"><br></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">10. this.&nbsp;</span></b></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;iv와 lv를 구분하기 위해 사용된다. 인스턴스 자신을 가리키는 참조변수이고, 인스턴스 주소를 저장한다.</span></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;"><br></span></span></p><p style="margin-left: 2em;"><br></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">11. 변수의 초기화</span></b></span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">① lv : 수동초기화. ( int a = 5; )</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">② iv : 생성동시 default 값으로 자동초기화. (멤버변수)</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">③ cv : 자동초기화</span><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">&nbsp;</span><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">default 값으로</span><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">&nbsp;자동초기화 된다.&nbsp;</span><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">(멤버변수)&nbsp;</span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 6em;"><font color="#222222"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);"><b><span style="color: rgb(0, 0, 0);">11.1) 초기화 순서</span></b><span style="color: rgb(0, 0, 0);"> (cv - iv 순으로 초기화 후, 자동 - 간단 - 복잡 순으로 초기화)</span></span></font></p><p style="margin-left: 6em;"><span style="font-size: 12pt;"><br></span></p><p style="margin-left: 6em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);">-&nbsp; lv ) only 수동초기화.</span></p><p style="margin-left: 6em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);">-&nbsp; iv ) 자동초기화(default 값)&nbsp;- 대입 - 초기화블럭 - 생성자 순으로 초기화.</span></p><p style="margin-left: 6em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);">-&nbsp; cv ) 자동초기화</span><span style="font-size: 12pt; color: rgb(0, 0, 0);">(default 값)</span><span style="font-size: 12pt; color: rgb(0, 0, 0);">&nbsp;- 대입 - static 초기화블럭 순으로 초기화.</span></p><p style="margin-left: 6em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 6em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">① 자동초기화 (default 값)</span></p><p style="margin-left: 6em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">② 명시적초기화 (대입연산)</span></p><p style="margin-left: 6em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">③ 복잡초기화 및 생성자를 통한 초기화.</span></p><p style="margin-left: 6em;"><br></p><p style="background-color: transparent; color: rgb(48, 48, 48); font-size: 16px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 22.08px; margin-left: 6em; margin-right: 0px; padding: 0px;" dir="ltr"><span style="background-color: transparent; color: rgb(0, 0, 0); font-variant-numeric: normal; font-variant-east-asian: normal; vertical-align: baseline; white-space: pre-wrap;">※&nbsp;&nbsp;초기화 시점</span></p><p style="background-color: transparent; color: rgb(48, 48, 48); font-size: 16px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 22.08px; margin-left: 6em; margin-right: 0px; padding: 0px;" dir="ltr"><span style="background-color: transparent; color: rgb(0, 0, 0); font-variant-numeric: normal; font-variant-east-asian: normal; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;* 클래스변수의 초기화시점 : 클래스가 처음 로딩될 때 단 한번 초기화 된다. </span></p><p style="background-color: transparent; color: rgb(48, 48, 48); font-size: 16px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 22.08px; margin-left: 6em; margin-right: 0px; padding: 0px;" dir="ltr"><span style="background-color: transparent; color: rgb(0, 0, 0); font-variant-numeric: normal; font-variant-east-asian: normal; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;* 인스턴스변수의 초기화시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.</span></p><p style="background-color: transparent; color: rgb(48, 48, 48); font-size: 16px; font-variant-numeric: normal; font-variant-east-asian: normal; margin-left: 6em; margin-right: 0px; padding: 0px;"><br></p><p style="background-color: transparent; color: rgb(48, 48, 48); font-size: 16px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 22.08px; margin-left: 6em; margin-right: 0px; padding: 0px;" dir="ltr"><span style="background-color: transparent; color: rgb(0, 0, 0); font-variant-numeric: normal; font-variant-east-asian: normal; vertical-align: baseline; white-space: pre-wrap;">※&nbsp;&nbsp;초기화 순서</span></p><p style="background-color: transparent; color: rgb(48, 48, 48); font-size: 16px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 22.08px; margin-left: 6em; margin-right: 0px; padding: 0px;" dir="ltr"><span style="background-color: transparent; color: rgb(0, 0, 0); font-variant-numeric: normal; font-variant-east-asian: normal; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;* 클래스변수의 초기화순서 : 기본값 -&gt; 명시적초기화 -&gt; 클래스 초기화 블럭 </span></p><p style="background-color: transparent; color: rgb(48, 48, 48); font-size: 16px; font-variant-numeric: normal; font-variant-east-asian: normal; line-height: 22.08px; margin-left: 6em; margin-right: 0px; padding: 0px;" dir="ltr"><span style="background-color: transparent; color: rgb(0, 0, 0); font-variant-numeric: normal; font-variant-east-asian: normal; vertical-align: baseline; white-space: pre-wrap;"> &nbsp;&nbsp;&nbsp;* 인스턴스변수의 초기화순서 : 기본값 -&gt; 명시적초기화 -&gt; 인스턴스 초기화 블럭 -&gt; 생성자</span></p><p style="margin-left: 6em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);"><br></span></p><p style="margin-left: 8em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);"><b><span style="color: rgb(0, 0, 0);">11.1.1 )&nbsp;</span></b></span></font><span style="font-size: 16px;"><b><span style="color: rgb(0, 0, 0);">static 변수 선언부</span></b></span></p><p style="margin-left: 8em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);">&nbsp;</span></font><span style="font-size: 12pt; color: rgb(0, 0, 0);">클래스가 로드 될 때 변수가 제일 먼저 초기화 됨. 메모리 모델상 Method area에 올라감.</span></p><p style="margin-left: 8em;"><span style="font-size: 12pt;"><br></span></p><p style="margin-left: 8em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);"><b><span style="color: rgb(0, 0, 0);">11.1.2&nbsp;)필드 변수 선언부</span></b></span></font></p><p style="margin-left: 8em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);">&nbsp;</span></font><span style="font-size: 12pt; color: rgb(0, 0, 0);">객체 생성 될 때 생성자 block보다 앞서 초기화 됨. 메모리 모델상 Heap area에 올라감.</span></p><p style="margin-left: 8em;"><span style="font-size: 12pt;"><br></span></p><p style="margin-left: 8em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);"><b><span style="color: rgb(0, 0, 0);">11.1.3&nbsp;)생성자 block</span></b></span></font></p><p style="margin-left: 8em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);"> 객체 생성 될 때 JVM이 내부적으로 locking 한다. (thread safe 영역) 필드 변수 중 final 변수의 가시화는 필드 변수 선언부에서 이미 초기화 되었다면 그 값들은 덮어 씀.&nbsp;</span></font></p><p style="margin-left: 8em;"><span style="font-size: 12pt;"><br></span></p><p style="margin-left: 6em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);"><br></span></p><p style="margin-left: 6em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">12. 상속&nbsp;</span></b></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;두 클래스를 조상과 자손으로 관계를 맺어주는 것. (1.7 오버라이딩 참고)</span></span></p><p style="margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">- 조건</span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-family: &quot;Helvetica Neue&quot;, &quot;Apple SD Gothic Neo&quot;, 나눔고딕, NanumGothic, &quot;맑은 고딕&quot;, &quot;Malgun Gothic&quot;, 돋움, Dotum, sans-serif; font-size: 10pt;"><span style="font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt; color: rgb(0, 0, 0);">①</span><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">&nbsp;</span></span><span style="color: rgb(0, 0, 0); font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt;">초기화블럭 및 생성자는 제외한&nbsp;</span><span style="color: rgb(0, 0, 0); font-family: &quot;맑은 고딕&quot;, sans-serif; font-size: 12pt;">자손은 조상의 모든멤버를 상속받는다.&nbsp;</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">② 자손의 멤버 갯수가 조상의 멤버 갯수보다 같거나 많다. (조상멤버갯수 &gt;= 조상멤버갯수)</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">③ 공통부분은 조상이 관리하고, 개별부분은 자손이 관리한다. 조상클래스의 멤버가 변경되면 상속받은 자손클래스들이 모두 영향을&nbsp; &nbsp; &nbsp; &nbsp; 받는다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">④ 자손은 하나의 조상만을 상속받을 수 있다.</span></p><p style="margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">※ 상속과 객체생성 차이는 ..이다., ..를 가지고 있다. 의 차이로 그 관계를&nbsp;비유. 상속&nbsp; = is a, 객체생성 = has a</span></p><p style="margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">&nbsp;</span></p><p style="margin-left: 4em;"><br></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">13. super&nbsp;</span></b></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp; this와 유사, 조상의 멤버와 자손의 멤버를 구별하기 위해 사용한다.</span></span></p><p style="margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">- 자손클래스의 인스턴스를 생성하면 조상의 멤버들도 초기화 하기 위해 자손의 생성자 첫 문장에서 조상의 생성자 super()를 호출한다.&nbsp;</span></p><p style="margin-left: 4em;"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);"><br></span></p><p style="margin-left: 2em;"><br></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">14. 패키지&nbsp;</span></b></span></p><p style="margin-left: 2em;"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0);">&nbsp;<span style="font-size: 12pt;">서로 관련된 클래스의 묶음이며, 서브패키지를 가질 수 있고 \'&nbsp;. \'&nbsp;으로 구분한다.&nbsp;</span></span></span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">- 조건</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">① 클래스 맨 위에 선언한다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">② 하나의 소스파일(클래스)에서 1개의 public class 만을 가진다.&nbsp;</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">15. import&nbsp;</span></b></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;사용할 클래스와 속한 패키지를 지정하는데 사용한다. import문 사용 시, 사용할 클래스의 패키지 명을 생략할 수 있다.</span></span></p><p style="margin-left: 4em;"><font color="#222222"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);">ex )&nbsp;\'import java.uti.Date;\' 라고 선언시\' java.util.Date date = new java.util.Date();\' 를 다음과 같이 사용가능. \'Date date = new Date();\'</span></font></p><p style="margin-left: 4em;"><font color="#222222"><span style="font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif; color: rgb(0, 0, 0);"><br></span></font></p><p style="margin-left: 4em;"><font color="#222222"><span style="font-size: 13.3333px;"><br></span></font></p><p style="margin-left: 2em;"><font color="#222222"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">16. 접근제어자&nbsp;</span></b></span></font></p><p style="margin-left: 2em;"><font color="#222222"><span style="font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;외부로 부터 데이터를 보호하고 복잡도를 줄이기 위해 사용.</span></span></font></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">① public : 접근제한이 없음.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">② default : 같은 패키지 내에서만 접근 가능.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">③ protected : 타 패키지 자손클래스 및 같은클래스 내에서만 접근 가능.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;">④ private : 같은 클래스에서만 접근 가능.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><br></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><b><span style="color: rgb(255, 0, 0);">17.&nbsp;다형성&nbsp;</span></b></span></p><p style="margin-left: 2em;"><span style="color: rgb(34, 34, 34); font-size: 14pt; font-family: &quot;맑은 고딕&quot;, sans-serif;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">&nbsp;조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는 것.&nbsp;</span></span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">① 참조변수의 형변환 : 다룰 수 있는 멤버 갯수를 줄이거나 늘릴 수 있다. 단, 서로 상속관계에 있는 타입간의 형변환만 가능하다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">② instanceof : 형변환 여부 확인을 위해 사용한다. a instanceof b의 값이 true이면 해당타입으로 형변환이 가능하다. 이를 통해 참조변수가 참조하는 인스턴스의 실제타입을 체크한다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">③ 멤버변수, 메서드가 중복 정의된 경우 사용한다.&nbsp;</span></p><p style="margin-left: 6em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">ex)&nbsp;&nbsp;&nbsp;&nbsp;- parent method = this.method</span></p><p style="margin-left: 10em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);">- child method = this.method</span></p><p style="margin-left: 10em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);">- parent.변수 = super.변수</span></p><p style="margin-left: 10em;"><span style="font-size: 12pt; color: rgb(0, 0, 0);">- child.변수 = super.변수</span></p><p style="margin-left: 4em;"><br></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;"><b>17.1) 다형성의 장점</b></span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">① 여러가지 타입의 객체를 하나의 객체로 다룰 수 있다.</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;">② 메서드 호출 시, 자신과 같은 타입 혹은 자손타입의 인스턴스를 넘겨줄 수 있다.&nbsp;</span></p><p style="margin-left: 4em;"><span style="color: rgb(0, 0, 0); font-size: 12pt;"><br></span></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 14pt;"><br></span></p><p style="margin-left: 2em;"><b style="color: rgb(34, 34, 34); font-size: 18.6667px;"><span style="color: rgb(255, 0, 0);">18. 추상클래스</span></b></p><p style="margin-left: 2em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);">&nbsp;클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다. 미완성 설계도란, 단어의 뜻 그대로 완성되지 못한 채로 남겨진 설계도를 말한다. 클래스가 미완성이라는 것은 멤버의 갯수에 관계된 것이 아니라, 단지 미완성메서드 즉 추상메서드를 포함하고 있다는 의미이다. 미완성 설계도로 완성된 제품을 만들 수 없듯이 추상클래스로 인스턴스는 생성할 수 없다. 추상클래스는 상속을 통해서 자손클래스에 의해서만 형성될 수 있다.&nbsp;</span></font></p><p style="margin-left: 2em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);"><br></span></font></p><p style="margin-left: 2em;"><font color="#222222"><span style="font-size: 18.6667px;"><br></span></font></p><p style="margin-left: 2em;"><b style="color: rgb(34, 34, 34); font-size: 18.6667px;"><span style="color: rgb(255, 0, 0);">19. 인터페이스</span></b></p><p style="margin-left: 2em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);">&nbsp;인터페이스는 일종의 추상클래스이다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만 추상클래스 보다 추상화 정도가 높아서 추상클래와는 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그외의 어떠한 요소도 허용하지 않는다.&nbsp;</span></font></p><p style="margin-left: 2em;"><font color="#222222"><span style="font-size: 12pt; color: rgb(0, 0, 0);">&nbsp;추상클래스를 부분적으로만 완성된 \'미완성 설계도\' 라고 한다면, 인터페이스는&nbsp;구현된 것은 아무것도 없고 밑그림만 그려져 있는 \'기본 설계도\' 라고 할 수 있다. 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와는 달리 다중상속, 즉 여러 개의 인터페이스로 부터 상속 받는 것이 가능하다.&nbsp;</span></font></p><p style="margin-left: 2em;"><span style="font-size: 12pt;">&nbsp;</span></p><p style="margin-left: 2em;"><b><span style="font-size: 12pt; color: rgb(0, 0, 0);">&nbsp;</span><span style="font-size: 16px; white-space: pre-wrap; color: rgb(0, 0, 0);">※</span><span style="font-size: 12pt; color: rgb(0, 0, 0);">&nbsp;인터페이스 사용 이유</span></b></p><p style="margin-left: 2em;"><span style="font-size: 16px;">&nbsp;다형성을 구현하기 위해 사용한다. 같은 인터페이스를 구현하는 클래스들은 실행하는 객체가 인터페이스를 통하여다른 객체를 사용할 수 있도록 하여 클래스간의 결합도를 낮추고 응집도를 높힐 수 있다. 그 예로 Spring에서 DI(의존성 주입)을 통해서 다형성을 구현하고 결합도를 낮추기 위해 사용한다.&nbsp;</span></p><p style="margin-left: 4em;"><br></p><p style="margin-top: 0px; margin-bottom: 0px;"><br></p><p style="margin-left: 4em;"><span style="color: rgb(34, 34, 34); font-size: 13.3333px;"><br></span></p><p style="margin-left: 4em;"><br></p><p style="margin-left: 2em;"><br></p><p><br></p><p><br></p><p><br></p></div>\n\t\t\t\t\t\t</div>'}],viewItems:[],tags:[]}},created:function(){this.init()},methods:{init:function(){this.items=this.items.sort((function(t,s){return t.sort>s.sort?-1:t.sort<s.sort?1:0})),this.viewItems=this.items;for(var t=this.items.map((function(t){return t.tags})),s=0;s<t.length;s++)this.tags=this.tags.concat(this.tags,t[s]);this.tags=Array.from(new Set(this.tags))},doTagSearch:function(t){this.viewItems=this.items.filter((function(s){return s.tags.indexOf(t)>-1}))}}};s["a"]=e},f183:function(t,s,n){var e=n("d012"),i=n("861d"),p=n("5135"),a=n("9bf2").f,o=n("90e3"),l=n("bb2f"),r=o("meta"),f=0,y=Object.isExtensible||function(){return!0},b=function(t){a(t,r,{value:{objectID:"O"+ ++f,weakData:{}}})},g=function(t,s){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!p(t,r)){if(!y(t))return"F";if(!s)return"E";b(t)}return t[r].objectID},m=function(t,s){if(!p(t,r)){if(!y(t))return!0;if(!s)return!1;b(t)}return t[r].weakData},c=function(t){return l&&d.REQUIRED&&y(t)&&!p(t,r)&&b(t),t},d=t.exports={REQUIRED:!1,fastKey:g,getWeakData:m,onFreeze:c};e[r]=!0},fdbc:function(t,s){t.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}}}]);
//# sourceMappingURL=chunk-0414f2d6.40454b3c.js.map