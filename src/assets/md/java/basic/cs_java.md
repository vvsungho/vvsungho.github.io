## **기술 면접 정리 - Java**
---
⭐⭐
#### <span style="color: green;">**자바 프로그램 실행 과정**</span>
첫 번째로 컴파일러가 자바 소스를 바이트코드로 변환합니다.

그 후 클래스 로더가 바이트 코드를 런타임 데이터 영역에 로드합니다.

그 후 로딩된 바이트 코드가 실행엔진에 의해서 실행되게 됩니다.  
</br>

⭐⭐
#### <span style="color: green;">**객체지향 프로그래밍**</span>

현실 세계의 사물같은 객체를 만들고 객체에서 필요한 특징을 뽑아 프로그램을 수행하는 것 입니다.

객체지향 프로그래밍은 총 4가지 특징이 있습니다.

4가지 특징은 **추상화, 캡슐화, 상속, 다형성** 입니다.

첫 번쨰로 **추상화**는

객체의 공통적인 속성과 기능을 추출하여 정의하는 것이고 객체들의 공통된 특징을 파악해 정의해놓은 개념입니다.

다음으로 **캡슐화**는

캡슐화는 데이터와 코드의 형태를 외부로 알 수 없게 하고, 데이터의 구조와 역할, 기능을 하나의 캡슐형태로 만드는 방법 입니다.

캡슐화의 중요한 목적은 변수를 private으로 선언하여 데이터를 보호하고, 보호된 변수는 setter/getter나 생성자 등을 통해서만 간접적으로 접근을 허용하게끔 하는 것이고, 캡슐화를 하면 불필요한 정보를 감출 수 있기 떄문에, 정보 은닉을 할 수 있다는 장점이 있습니다.

다음으로 **상속**은

상속은 상위클래스의 기능을 가져와 재사용할 수 있으면서도 동시에 새로운 하위 클레스에 새로운 기능도 추가할 수 있는 것을 의미합니다.

마지막으로 **다형성**은

다형성은 한 객체가 구현을 통해 기능을 확장하거나 변경하여 다른 형태의 객체로 재구성되는 것을 의미합니다.

다형성을 통해 역할과 구현을 분리하는 것이 핵심이고 확장할 구현 객체만 작업하면되기 때문에 유지보수에 이점을 가지고 있습니다  
</br>

⭐⭐
#### <span style="color: green;">**추상클래스, 인터페이스 비교**</span>

추상 클래스는 absstract 지시자로 정의되어서 추상메서드가 하나 이상 포함되는 클래스 입니다.

인터페이스는 interface 지시자로 정의되어서 모든 메서드가 추상메서드로 정의되게 됩니다. (java8  부터는 디폴트 메서드를 가질 수 있으며 구현까지 가능하다.)

추상클래스와 인터페이스의 차이는 다중 상속 가능유무에 대한 차이가 있습니다.

또한 추상클래스와 인터페이스의 차이는 그 존재 목적에 있습니다.

추상 클래스는 상속받아서 기능을 재활용하고 확장시키는데 목적이 있다고 하면

인터페이스는 함수의 구현을 강제해서 구현한 객체들이 같은 동작을 하는 것을 보장하는 것에 그 목적이 있습니다.

(추상 클래스에는 원하는 것만 추상 메서드를 두고 일반메서드를 가질 수 있다. 모든 것을 인터페이스로 구현하게 된다면 공통된 작업에 대한 코드에 대해서 모두 오버라이딩 해야하는 단점이 있다.)  
</br>

⭐⭐
#### <span style="color: green;">**상속, 다형성 차이**</span>

상속과 다형성의 차이로는 다중상속의 가능 여부 차이가 있으며, 상속은 구현체를 가져와 그대로 사용할 수 있지만 다형성은 구체화를 반드시 해야하는 차이가 있습니다.  
</br>

⭐
#### <span style="color: green;">**자바 메모리 구조**</span>

자바 메모리 구조는 크게 5가지 영역으로 구분됩니다.
우선 스레드마다 PC Register, JVM Stack, Native Method Stack이 있고 스레드 공통으로는 Heap과 Method영역이 있습니다.

PC Register는 현재 수행중인 JVM명령어가 들어가 있고,

JVM Stack은 호출된 메서드의 매개변수, 지역변수, 리턴정보들이 저장됩니다.

Native Method Stack은 자바 외의 언어인 C나 C++ 같은 것들을 수행하기 위한 영역이고,

Method 영역은 클래스 별로 전역변수, 정적 변수, 메서드 정보들이 저장되게 됩니다.

마지막으로 Heap영역은 런타임중 생성되는 객체들이 동적으로 할당되는 곳 입니다.  
</br>

⭐
#### <span style="color: green;">**가비지 컬렉션**</span>

가비지 컬렉션은 JVM에서 메모리를 관리해주는 모듈입니다.

Heap 메모리를 재활용하기 위해서 더 이상 참조되지 않는 객체들을 메모리에서 제거하는 모듈입니다.

개발자가 직접 메모리를 정리하지 않아도 되어서 개발속도가 향상되는 장점이 있지만

Mark And Sweap이라는 과정에서 참조되지 않는 객체를 찾는 과정이 있는데, 이 때 쓰레드가 잠깐 중단되어서 성능이 떨어진다는 단점이 있습니다.  
</br>

⭐
#### <span style="color: green;">**객체지향 프로그래밍 장점**</span>

객체지향은 캡슐화, 추상화, 상속, 다형성 같은 특성이 있습니다.

이러한 객체지향의 특성과 객체를 잘 설계함으로써 코드의 재사용성을 높이고 유지보수를 수월하게 함으로써 개발의 생산성을 높일 수 있고,

생각하고 있는 그대로를 자연스럽게 구현할 수 있기 때문에 모델링에 우수하다는 장점이 있습니다.  
</br>

⭐
#### <span style="color: green;">**객체지향 프로그래밍의 5가지 설계 원칙 (SOLID)에 대해 설명해주세요.**</span>
SOLID란 객체 지향 프로그래밍을 하면서 지켜야하는 5대 원칙 입니다.  
SOLID 원칙을 철저히 지키면 시간이 지나도 유지보수와 확장이 쉬운 소프트웨어 개발하는데 도움이 됩니다.  
**단일 책임 원칙** (SRP)  
하나의 모듈은 한 가지 책임을 가져야 하고, 모듈이 변경되는 이유가 한 가지여야 한다는 것을 의미합니다. 단일 책임 원칙을 잘 적용함으로써 변경이 필요할 때 수정할 대상이 명확해집니다.  

**개방 폐쇄 원칙** (OCP)  
개방 폐쇄 원칙은 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다는 원칙 입니다.  
여기서 “확장에 대해 열려있다.” 는 의미는 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다는 것을 의미하고,  
“수정에 대해 닫혀 있다.” 라는 의미는 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다는 것을 의미합니다.  

**인터페이스 분리 원칙** (ISP)
클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것을 의미하는데 인터페이스 분리 원칙을 잘 적용함으로써 기존 클라이언트에 영향을 주지 않은 채로 유연하게 객체의 기능을 확장하거나 수정할 수 있습니다.  

**리스코프 치환 원칙** (LSP)
하위 타입은 상위타입을 대체할 수 있어야 한다는 의미입니다.  
객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도, 상위 타입의 동작을 완벽하게 대체할 수 있도록 설계해야 한다는 의미 입니다.  

**의존 역전 원칙** (DIP)
고수준의 모듈은 저수준의 모듈의 구현에 의존해서는 안된다는 의미 입니다.  
다시 말해 의존 관계를 맺을 때 변하기 어려운 것에 의존해야한다는 의미인데, 구체화된 클래스에 직접적인 의존관계를 맺지 않고 인터페이스나 추상 클래스에 의존관계를 맺는 것을 의미합니다.  
<br/>

#### <span style="color: red;">보충 필요 내용</span>
- 접근자
- static
- Wrapper
- 오버로딩
- 오버라이딩
- JWT
- 박싱과 언박싱이란?
- 직렬화(serialization)란?
- String vs StringBuffer vs StringBuilder
- try-with-resource란?
- Synchronized(동기화)란?
- 제네릭이란?
- CheckedException과 UnCheckedException의 차이  
</br>
#### <span style="">**참고 자료**</span>

[면접 질문 정리](https://junjangsee.github.io/2019/05/15/interview/interview/)
</br>
</br>
</br>
</br>
